{"ast":null,"code":"import _defineProperty from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _objectSpread from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _createForOfIteratorHelper from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createAudioWorkletProcessor } from '../helpers/create-audio-worklet-processor';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { ReadOnlyMap } from '../read-only-map';\nexport var createNativeAudioWorkletNodeFakerFactory = function createNativeAudioWorkletNodeFakerFactory(auxiliaryGainNodeStore, connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, monitorConnections) {\n  return function (nativeContext, baseLatency, processorConstructor, options) {\n    if (options.numberOfInputs === 0 && options.numberOfOutputs === 0) {\n      throw createNotSupportedError();\n    }\n\n    if (options.outputChannelCount !== undefined) {\n      // @todo Check if any of the channelCount values is greater than the implementation's maximum number of channels.\n      if (options.outputChannelCount.some(function (channelCount) {\n        return channelCount < 1;\n      })) {\n        throw createNotSupportedError();\n      }\n\n      if (options.outputChannelCount.length !== options.numberOfOutputs) {\n        throw createIndexSizeError();\n      }\n    } // Bug #61: This is not part of the standard but required for the faker to work.\n\n\n    if (options.channelCountMode !== 'explicit') {\n      throw createNotSupportedError();\n    }\n\n    var numberOfInputChannels = options.channelCount * options.numberOfInputs;\n    var numberOfOutputChannels = options.outputChannelCount.reduce(function (sum, value) {\n      return sum + value;\n    }, 0);\n    var numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length; // Bug #61: This is not part of the standard but required for the faker to work.\n\n    if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {\n      throw createNotSupportedError();\n    }\n\n    var messageChannel = new MessageChannel();\n    var gainNodes = [];\n    var inputChannelSplitterNodes = [];\n\n    for (var i = 0; i < options.numberOfInputs; i += 1) {\n      gainNodes.push(createNativeGainNode(nativeContext, {\n        channelCount: options.channelCount,\n        channelCountMode: options.channelCountMode,\n        channelInterpretation: options.channelInterpretation,\n        gain: 1\n      }));\n      inputChannelSplitterNodes.push(createNativeChannelSplitterNode(nativeContext, {\n        channelCount: options.channelCount,\n        channelCountMode: 'explicit',\n        channelInterpretation: 'discrete',\n        numberOfOutputs: options.channelCount\n      }));\n    }\n\n    var constantSourceNodes = [];\n\n    if (processorConstructor.parameterDescriptors !== undefined) {\n      var _iterator = _createForOfIteratorHelper(processorConstructor.parameterDescriptors),\n          _step;\n\n      try {\n        var _loop = function _loop() {\n          var _step$value = _step.value,\n              defaultValue = _step$value.defaultValue,\n              maxValue = _step$value.maxValue,\n              minValue = _step$value.minValue,\n              name = _step$value.name;\n          var constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            offset: options.parameterData[name] !== undefined ? options.parameterData[name] : defaultValue === undefined ? 0 : defaultValue\n          });\n          Object.defineProperties(constantSourceNode.offset, {\n            defaultValue: {\n              get: function get() {\n                return defaultValue === undefined ? 0 : defaultValue;\n              }\n            },\n            maxValue: {\n              get: function get() {\n                return maxValue === undefined ? MOST_POSITIVE_SINGLE_FLOAT : maxValue;\n              }\n            },\n            minValue: {\n              get: function get() {\n                return minValue === undefined ? MOST_NEGATIVE_SINGLE_FLOAT : minValue;\n              }\n            }\n          });\n          constantSourceNodes.push(constantSourceNode);\n        };\n\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n\n    var inputChannelMergerNode = createNativeChannelMergerNode(nativeContext, {\n      channelCount: 1,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'speakers',\n      numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n    });\n    var bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n    var scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, numberOfInputChannels + numberOfParameters, // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n    Math.max(1, numberOfOutputChannels));\n    var outputChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n      channelCount: Math.max(1, numberOfOutputChannels),\n      channelCountMode: 'explicit',\n      channelInterpretation: 'discrete',\n      numberOfOutputs: Math.max(1, numberOfOutputChannels)\n    });\n    var outputChannelMergerNodes = [];\n\n    for (var _i = 0; _i < options.numberOfOutputs; _i += 1) {\n      outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeContext, {\n        channelCount: 1,\n        channelCountMode: 'explicit',\n        channelInterpretation: 'speakers',\n        numberOfInputs: options.outputChannelCount[_i]\n      }));\n    }\n\n    for (var _i2 = 0; _i2 < options.numberOfInputs; _i2 += 1) {\n      gainNodes[_i2].connect(inputChannelSplitterNodes[_i2]);\n\n      for (var j = 0; j < options.channelCount; j += 1) {\n        inputChannelSplitterNodes[_i2].connect(inputChannelMergerNode, j, _i2 * options.channelCount + j);\n      }\n    }\n\n    var parameterMap = new ReadOnlyMap(processorConstructor.parameterDescriptors === undefined ? [] : processorConstructor.parameterDescriptors.map(function (_ref, index) {\n      var name = _ref.name;\n      var constantSourceNode = constantSourceNodes[index];\n      constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n      constantSourceNode.start(0);\n      return [name, constantSourceNode.offset];\n    }));\n    inputChannelMergerNode.connect(scriptProcessorNode);\n    var channelInterpretation = options.channelInterpretation;\n    var onprocessorerror = null; // Bug #87: Expose at least one output to make this node connectable.\n\n    var outputAudioNodes = options.numberOfOutputs === 0 ? [scriptProcessorNode] : outputChannelMergerNodes;\n    var nativeAudioWorkletNodeFaker = {\n      get bufferSize() {\n        return bufferSize;\n      },\n\n      get channelCount() {\n        return options.channelCount;\n      },\n\n      set channelCount(_) {\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        throw createInvalidStateError();\n      },\n\n      get channelCountMode() {\n        return options.channelCountMode;\n      },\n\n      set channelCountMode(_) {\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        throw createInvalidStateError();\n      },\n\n      get channelInterpretation() {\n        return channelInterpretation;\n      },\n\n      set channelInterpretation(value) {\n        var _iterator2 = _createForOfIteratorHelper(gainNodes),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var gainNode = _step2.value;\n            gainNode.channelInterpretation = value;\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        channelInterpretation = value;\n      },\n\n      get context() {\n        return scriptProcessorNode.context;\n      },\n\n      get inputs() {\n        return gainNodes;\n      },\n\n      get numberOfInputs() {\n        return options.numberOfInputs;\n      },\n\n      get numberOfOutputs() {\n        return options.numberOfOutputs;\n      },\n\n      get onprocessorerror() {\n        return onprocessorerror;\n      },\n\n      set onprocessorerror(value) {\n        if (typeof onprocessorerror === 'function') {\n          nativeAudioWorkletNodeFaker.removeEventListener('processorerror', onprocessorerror);\n        }\n\n        onprocessorerror = typeof value === 'function' ? value : null;\n\n        if (typeof onprocessorerror === 'function') {\n          nativeAudioWorkletNodeFaker.addEventListener('processorerror', onprocessorerror);\n        }\n      },\n\n      get parameters() {\n        return parameterMap;\n      },\n\n      get port() {\n        return messageChannel.port2;\n      },\n\n      addEventListener: function addEventListener() {\n        return scriptProcessorNode.addEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n      },\n      connect: connectMultipleOutputs.bind(null, outputAudioNodes),\n      disconnect: disconnectMultipleOutputs.bind(null, outputAudioNodes),\n      dispatchEvent: function dispatchEvent() {\n        return scriptProcessorNode.dispatchEvent(arguments.length <= 0 ? undefined : arguments[0]);\n      },\n      removeEventListener: function removeEventListener() {\n        return scriptProcessorNode.removeEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n      }\n    };\n    var patchedEventListeners = new Map();\n\n    messageChannel.port1.addEventListener = function (addEventListener) {\n      return function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        if (args[0] === 'message') {\n          var unpatchedEventListener = typeof args[1] === 'function' ? args[1] : typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function' ? args[1].handleEvent : null;\n\n          if (unpatchedEventListener !== null) {\n            var patchedEventListener = patchedEventListeners.get(args[1]);\n\n            if (patchedEventListener !== undefined) {\n              args[1] = patchedEventListener;\n            } else {\n              args[1] = function (event) {\n                exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, function () {\n                  return unpatchedEventListener(event);\n                });\n              };\n\n              patchedEventListeners.set(unpatchedEventListener, args[1]);\n            }\n          }\n        }\n\n        return addEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n      };\n    }(messageChannel.port1.addEventListener);\n\n    messageChannel.port1.removeEventListener = function (removeEventListener) {\n      return function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        if (args[0] === 'message') {\n          var patchedEventListener = patchedEventListeners.get(args[1]);\n\n          if (patchedEventListener !== undefined) {\n            patchedEventListeners.delete(args[1]);\n            args[1] = patchedEventListener;\n          }\n        }\n\n        return removeEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n      };\n    }(messageChannel.port1.removeEventListener);\n\n    var onmessage = null;\n    Object.defineProperty(messageChannel.port1, 'onmessage', {\n      get: function get() {\n        return onmessage;\n      },\n      set: function set(value) {\n        if (typeof onmessage === 'function') {\n          messageChannel.port1.removeEventListener('message', onmessage);\n        }\n\n        onmessage = typeof value === 'function' ? value : null;\n\n        if (typeof onmessage === 'function') {\n          messageChannel.port1.addEventListener('message', onmessage);\n          messageChannel.port1.start();\n        }\n      }\n    });\n    processorConstructor.prototype.port = messageChannel.port1;\n    var audioWorkletProcessor = null;\n    var audioWorkletProcessorPromise = createAudioWorkletProcessor(nativeContext, nativeAudioWorkletNodeFaker, processorConstructor, options);\n    audioWorkletProcessorPromise.then(function (dWrkltPrcssr) {\n      return audioWorkletProcessor = dWrkltPrcssr;\n    });\n    var inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n    var outputs = createNestedArrays(options.numberOfOutputs, options.outputChannelCount);\n    var parameters = processorConstructor.parameterDescriptors === undefined ? [] : processorConstructor.parameterDescriptors.reduce(function (prmtrs, _ref2) {\n      var name = _ref2.name;\n      return _objectSpread(_objectSpread({}, prmtrs), {}, _defineProperty({}, name, new Float32Array(128)));\n    }, {});\n    var isActive = true;\n\n    var disconnectOutputsGraph = function disconnectOutputsGraph() {\n      if (options.numberOfOutputs > 0) {\n        scriptProcessorNode.disconnect(outputChannelSplitterNode);\n      }\n\n      for (var _i3 = 0, outputChannelSplitterNodeOutput = 0; _i3 < options.numberOfOutputs; _i3 += 1) {\n        var outputChannelMergerNode = outputChannelMergerNodes[_i3];\n\n        for (var _j = 0; _j < options.outputChannelCount[_i3]; _j += 1) {\n          outputChannelSplitterNode.disconnect(outputChannelMergerNode, outputChannelSplitterNodeOutput + _j, _j);\n        }\n\n        outputChannelSplitterNodeOutput += options.outputChannelCount[_i3];\n      }\n    }; // tslint:disable-next-line:deprecation\n\n\n    scriptProcessorNode.onaudioprocess = function (_ref3) {\n      var inputBuffer = _ref3.inputBuffer,\n          outputBuffer = _ref3.outputBuffer;\n\n      if (audioWorkletProcessor !== null) {\n        var _loop2 = function _loop2(_i4) {\n          for (var _j2 = 0; _j2 < options.numberOfInputs; _j2 += 1) {\n            for (var k = 0; k < options.channelCount; k += 1) {\n              copyFromChannel(inputBuffer, inputs[_j2], k, k, _i4);\n            }\n          }\n\n          if (processorConstructor.parameterDescriptors !== undefined) {\n            processorConstructor.parameterDescriptors.forEach(function (_ref4, index) {\n              var name = _ref4.name;\n              copyFromChannel(inputBuffer, parameters, name, numberOfInputChannels + index, _i4);\n            });\n          }\n\n          for (var _j3 = 0; _j3 < options.numberOfInputs; _j3 += 1) {\n            for (var _k = 0; _k < options.outputChannelCount[_j3]; _k += 1) {\n              // The byteLength will be 0 when the ArrayBuffer was transferred.\n              if (outputs[_j3][_k].byteLength === 0) {\n                outputs[_j3][_k] = new Float32Array(128);\n              }\n            }\n          }\n\n          try {\n            var potentiallyEmptyInputs = inputs.map(function (input, index) {\n              var auxiliaryGainNodes = auxiliaryGainNodeStore.get(nativeAudioWorkletNodeFaker);\n\n              if (auxiliaryGainNodes === undefined || auxiliaryGainNodes.get(index) === undefined) {\n                return [];\n              }\n\n              return input;\n            });\n            var activeSourceFlag = exposeCurrentFrameAndCurrentTime(nativeContext.currentTime + _i4 / nativeContext.sampleRate, nativeContext.sampleRate, function () {\n              return audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters);\n            });\n            isActive = activeSourceFlag;\n\n            for (var _j4 = 0, outputChannelSplitterNodeOutput = 0; _j4 < options.numberOfOutputs; _j4 += 1) {\n              for (var _k2 = 0; _k2 < options.outputChannelCount[_j4]; _k2 += 1) {\n                copyToChannel(outputBuffer, outputs[_j4], _k2, outputChannelSplitterNodeOutput + _k2, _i4);\n              }\n\n              outputChannelSplitterNodeOutput += options.outputChannelCount[_j4];\n            }\n          } catch (error) {\n            isActive = false;\n            nativeAudioWorkletNodeFaker.dispatchEvent(new ErrorEvent('processorerror', {\n              error: error\n            }));\n          }\n\n          if (!isActive) {\n            for (var _j5 = 0; _j5 < options.numberOfInputs; _j5 += 1) {\n              gainNodes[_j5].disconnect(inputChannelSplitterNodes[_j5]);\n\n              for (var _k3 = 0; _k3 < options.channelCount; _k3 += 1) {\n                inputChannelSplitterNodes[_i4].disconnect(inputChannelMergerNode, _k3, _j5 * options.channelCount + _k3);\n              }\n            }\n\n            if (processorConstructor.parameterDescriptors !== undefined) {\n              var length = processorConstructor.parameterDescriptors.length;\n\n              for (var _j6 = 0; _j6 < length; _j6 += 1) {\n                var constantSourceNode = constantSourceNodes[_j6];\n                constantSourceNode.disconnect(inputChannelMergerNode, 0, numberOfInputChannels + _j6);\n                constantSourceNode.stop();\n              }\n            }\n\n            inputChannelMergerNode.disconnect(scriptProcessorNode);\n            scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n\n            if (isConnected) {\n              disconnectOutputsGraph();\n            } else {\n              disconnectFakeGraph();\n            }\n\n            return \"break\";\n          }\n        };\n\n        for (var _i4 = 0; _i4 < bufferSize; _i4 += 128) {\n          var _ret = _loop2(_i4);\n\n          if (_ret === \"break\") break;\n        }\n      }\n    };\n\n    var isConnected = false; // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n\n    var nativeGainNode = createNativeGainNode(nativeContext, {\n      channelCount: 1,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'discrete',\n      gain: 0\n    });\n\n    var connectFakeGraph = function connectFakeGraph() {\n      return scriptProcessorNode.connect(nativeGainNode)\n      /*\n       * Bug #50: Edge does not yet allow to create AudioNodes on a closed AudioContext. Therefore the context property is used here\n       * to make sure to connect the right destination.\n       */\n      .connect(nativeGainNode.context.destination);\n    };\n\n    var disconnectFakeGraph = function disconnectFakeGraph() {\n      scriptProcessorNode.disconnect(nativeGainNode);\n      nativeGainNode.disconnect();\n    };\n\n    var whenConnected = function whenConnected() {\n      if (isActive) {\n        disconnectFakeGraph();\n\n        if (options.numberOfOutputs > 0) {\n          scriptProcessorNode.connect(outputChannelSplitterNode);\n        }\n\n        for (var _i5 = 0, outputChannelSplitterNodeOutput = 0; _i5 < options.numberOfOutputs; _i5 += 1) {\n          var outputChannelMergerNode = outputChannelMergerNodes[_i5];\n\n          for (var _j7 = 0; _j7 < options.outputChannelCount[_i5]; _j7 += 1) {\n            outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + _j7, _j7);\n          }\n\n          outputChannelSplitterNodeOutput += options.outputChannelCount[_i5];\n        }\n      }\n\n      isConnected = true;\n    };\n\n    var whenDisconnected = function whenDisconnected() {\n      if (isActive) {\n        connectFakeGraph();\n        disconnectOutputsGraph();\n      }\n\n      isConnected = false;\n    };\n\n    connectFakeGraph();\n    return monitorConnections(nativeAudioWorkletNodeFaker, whenConnected, whenDisconnected);\n  };\n};","map":{"version":3,"sources":["../../../src/factories/native-audio-worklet-node-faker-factory.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createAudioWorkletProcessor } from '../helpers/create-audio-worklet-processor';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { ReadOnlyMap } from '../read-only-map';\nexport const createNativeAudioWorkletNodeFakerFactory = (auxiliaryGainNodeStore, connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, monitorConnections) => {\n    return (nativeContext, baseLatency, processorConstructor, options) => {\n        if (options.numberOfInputs === 0 && options.numberOfOutputs === 0) {\n            throw createNotSupportedError();\n        }\n        if (options.outputChannelCount !== undefined) {\n            // @todo Check if any of the channelCount values is greater than the implementation's maximum number of channels.\n            if (options.outputChannelCount.some((channelCount) => channelCount < 1)) {\n                throw createNotSupportedError();\n            }\n            if (options.outputChannelCount.length !== options.numberOfOutputs) {\n                throw createIndexSizeError();\n            }\n        }\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (options.channelCountMode !== 'explicit') {\n            throw createNotSupportedError();\n        }\n        const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n        const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n        const numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {\n            throw createNotSupportedError();\n        }\n        const messageChannel = new MessageChannel();\n        const gainNodes = [];\n        const inputChannelSplitterNodes = [];\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes.push(createNativeGainNode(nativeContext, {\n                channelCount: options.channelCount,\n                channelCountMode: options.channelCountMode,\n                channelInterpretation: options.channelInterpretation,\n                gain: 1\n            }));\n            inputChannelSplitterNodes.push(createNativeChannelSplitterNode(nativeContext, {\n                channelCount: options.channelCount,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                numberOfOutputs: options.channelCount\n            }));\n        }\n        const constantSourceNodes = [];\n        if (processorConstructor.parameterDescriptors !== undefined) {\n            for (const { defaultValue, maxValue, minValue, name } of processorConstructor.parameterDescriptors) {\n                const constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    offset: options.parameterData[name] !== undefined\n                        ? options.parameterData[name]\n                        : defaultValue === undefined\n                            ? 0\n                            : defaultValue\n                });\n                Object.defineProperties(constantSourceNode.offset, {\n                    defaultValue: {\n                        get: () => (defaultValue === undefined ? 0 : defaultValue)\n                    },\n                    maxValue: {\n                        get: () => (maxValue === undefined ? MOST_POSITIVE_SINGLE_FLOAT : maxValue)\n                    },\n                    minValue: {\n                        get: () => (minValue === undefined ? MOST_NEGATIVE_SINGLE_FLOAT : minValue)\n                    }\n                });\n                constantSourceNodes.push(constantSourceNode);\n            }\n        }\n        const inputChannelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'speakers',\n            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n        });\n        const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, numberOfInputChannels + numberOfParameters, \n        // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n        Math.max(1, numberOfOutputChannels));\n        const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n            channelCount: Math.max(1, numberOfOutputChannels),\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: Math.max(1, numberOfOutputChannels)\n        });\n        const outputChannelMergerNodes = [];\n        for (let i = 0; i < options.numberOfOutputs; i += 1) {\n            outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'speakers',\n                numberOfInputs: options.outputChannelCount[i]\n            }));\n        }\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n            for (let j = 0; j < options.channelCount; j += 1) {\n                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n            }\n        }\n        const parameterMap = new ReadOnlyMap(processorConstructor.parameterDescriptors === undefined\n            ? []\n            : processorConstructor.parameterDescriptors.map(({ name }, index) => {\n                const constantSourceNode = constantSourceNodes[index];\n                constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                constantSourceNode.start(0);\n                return [name, constantSourceNode.offset];\n            }));\n        inputChannelMergerNode.connect(scriptProcessorNode);\n        let channelInterpretation = options.channelInterpretation;\n        let onprocessorerror = null;\n        // Bug #87: Expose at least one output to make this node connectable.\n        const outputAudioNodes = options.numberOfOutputs === 0 ? [scriptProcessorNode] : outputChannelMergerNodes;\n        const nativeAudioWorkletNodeFaker = {\n            get bufferSize() {\n                return bufferSize;\n            },\n            get channelCount() {\n                return options.channelCount;\n            },\n            set channelCount(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelCountMode() {\n                return options.channelCountMode;\n            },\n            set channelCountMode(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelInterpretation() {\n                return channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                for (const gainNode of gainNodes) {\n                    gainNode.channelInterpretation = value;\n                }\n                channelInterpretation = value;\n            },\n            get context() {\n                return scriptProcessorNode.context;\n            },\n            get inputs() {\n                return gainNodes;\n            },\n            get numberOfInputs() {\n                return options.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return options.numberOfOutputs;\n            },\n            get onprocessorerror() {\n                return onprocessorerror;\n            },\n            set onprocessorerror(value) {\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.removeEventListener('processorerror', onprocessorerror);\n                }\n                onprocessorerror = typeof value === 'function' ? value : null;\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.addEventListener('processorerror', onprocessorerror);\n                }\n            },\n            get parameters() {\n                return parameterMap;\n            },\n            get port() {\n                return messageChannel.port2;\n            },\n            addEventListener(...args) {\n                return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n            },\n            connect: connectMultipleOutputs.bind(null, outputAudioNodes),\n            disconnect: disconnectMultipleOutputs.bind(null, outputAudioNodes),\n            dispatchEvent(...args) {\n                return scriptProcessorNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        const patchedEventListeners = new Map();\n        messageChannel.port1.addEventListener = ((addEventListener) => {\n            return (...args) => {\n                if (args[0] === 'message') {\n                    const unpatchedEventListener = typeof args[1] === 'function'\n                        ? args[1]\n                        : typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function'\n                            ? args[1].handleEvent\n                            : null;\n                    if (unpatchedEventListener !== null) {\n                        const patchedEventListener = patchedEventListeners.get(args[1]);\n                        if (patchedEventListener !== undefined) {\n                            args[1] = patchedEventListener;\n                        }\n                        else {\n                            args[1] = (event) => {\n                                exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () => unpatchedEventListener(event));\n                            };\n                            patchedEventListeners.set(unpatchedEventListener, args[1]);\n                        }\n                    }\n                }\n                return addEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.addEventListener);\n        messageChannel.port1.removeEventListener = ((removeEventListener) => {\n            return (...args) => {\n                if (args[0] === 'message') {\n                    const patchedEventListener = patchedEventListeners.get(args[1]);\n                    if (patchedEventListener !== undefined) {\n                        patchedEventListeners.delete(args[1]);\n                        args[1] = patchedEventListener;\n                    }\n                }\n                return removeEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.removeEventListener);\n        let onmessage = null;\n        Object.defineProperty(messageChannel.port1, 'onmessage', {\n            get: () => onmessage,\n            set: (value) => {\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.removeEventListener('message', onmessage);\n                }\n                onmessage = typeof value === 'function' ? value : null;\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.addEventListener('message', onmessage);\n                    messageChannel.port1.start();\n                }\n            }\n        });\n        processorConstructor.prototype.port = messageChannel.port1;\n        let audioWorkletProcessor = null;\n        const audioWorkletProcessorPromise = createAudioWorkletProcessor(nativeContext, nativeAudioWorkletNodeFaker, processorConstructor, options);\n        audioWorkletProcessorPromise.then((dWrkltPrcssr) => (audioWorkletProcessor = dWrkltPrcssr));\n        const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n        const outputs = createNestedArrays(options.numberOfOutputs, options.outputChannelCount);\n        const parameters = processorConstructor.parameterDescriptors === undefined\n            ? []\n            : processorConstructor.parameterDescriptors.reduce((prmtrs, { name }) => ({ ...prmtrs, [name]: new Float32Array(128) }), {});\n        let isActive = true;\n        const disconnectOutputsGraph = () => {\n            if (options.numberOfOutputs > 0) {\n                scriptProcessorNode.disconnect(outputChannelSplitterNode);\n            }\n            for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n                const outputChannelMergerNode = outputChannelMergerNodes[i];\n                for (let j = 0; j < options.outputChannelCount[i]; j += 1) {\n                    outputChannelSplitterNode.disconnect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                }\n                outputChannelSplitterNodeOutput += options.outputChannelCount[i];\n            }\n        };\n        // tslint:disable-next-line:deprecation\n        scriptProcessorNode.onaudioprocess = ({ inputBuffer, outputBuffer }) => {\n            if (audioWorkletProcessor !== null) {\n                for (let i = 0; i < bufferSize; i += 128) {\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < options.channelCount; k += 1) {\n                            copyFromChannel(inputBuffer, inputs[j], k, k, i);\n                        }\n                    }\n                    if (processorConstructor.parameterDescriptors !== undefined) {\n                        processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                            copyFromChannel(inputBuffer, parameters, name, numberOfInputChannels + index, i);\n                        });\n                    }\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                            // The byteLength will be 0 when the ArrayBuffer was transferred.\n                            if (outputs[j][k].byteLength === 0) {\n                                outputs[j][k] = new Float32Array(128);\n                            }\n                        }\n                    }\n                    try {\n                        const potentiallyEmptyInputs = inputs.map((input, index) => {\n                            const auxiliaryGainNodes = auxiliaryGainNodeStore.get(nativeAudioWorkletNodeFaker);\n                            if (auxiliaryGainNodes === undefined || auxiliaryGainNodes.get(index) === undefined) {\n                                return [];\n                            }\n                            return input;\n                        });\n                        const activeSourceFlag = exposeCurrentFrameAndCurrentTime(nativeContext.currentTime + i / nativeContext.sampleRate, nativeContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n                        isActive = activeSourceFlag;\n                        for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                            for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                                copyToChannel(outputBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                            }\n                            outputChannelSplitterNodeOutput += options.outputChannelCount[j];\n                        }\n                    }\n                    catch (error) {\n                        isActive = false;\n                        nativeAudioWorkletNodeFaker.dispatchEvent(new ErrorEvent('processorerror', { error }));\n                    }\n                    if (!isActive) {\n                        for (let j = 0; j < options.numberOfInputs; j += 1) {\n                            gainNodes[j].disconnect(inputChannelSplitterNodes[j]);\n                            for (let k = 0; k < options.channelCount; k += 1) {\n                                inputChannelSplitterNodes[i].disconnect(inputChannelMergerNode, k, j * options.channelCount + k);\n                            }\n                        }\n                        if (processorConstructor.parameterDescriptors !== undefined) {\n                            const length = processorConstructor.parameterDescriptors.length;\n                            for (let j = 0; j < length; j += 1) {\n                                const constantSourceNode = constantSourceNodes[j];\n                                constantSourceNode.disconnect(inputChannelMergerNode, 0, numberOfInputChannels + j);\n                                constantSourceNode.stop();\n                            }\n                        }\n                        inputChannelMergerNode.disconnect(scriptProcessorNode);\n                        scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n                        if (isConnected) {\n                            disconnectOutputsGraph();\n                        }\n                        else {\n                            disconnectFakeGraph();\n                        }\n                        break;\n                    }\n                }\n            }\n        };\n        let isConnected = false;\n        // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n        const nativeGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n        });\n        const connectFakeGraph = () => scriptProcessorNode\n            .connect(nativeGainNode)\n            /*\n             * Bug #50: Edge does not yet allow to create AudioNodes on a closed AudioContext. Therefore the context property is used here\n             * to make sure to connect the right destination.\n             */\n            .connect(nativeGainNode.context.destination);\n        const disconnectFakeGraph = () => {\n            scriptProcessorNode.disconnect(nativeGainNode);\n            nativeGainNode.disconnect();\n        };\n        const whenConnected = () => {\n            if (isActive) {\n                disconnectFakeGraph();\n                if (options.numberOfOutputs > 0) {\n                    scriptProcessorNode.connect(outputChannelSplitterNode);\n                }\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n                    for (let j = 0; j < options.outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n                    outputChannelSplitterNodeOutput += options.outputChannelCount[i];\n                }\n            }\n            isConnected = true;\n        };\n        const whenDisconnected = () => {\n            if (isActive) {\n                connectFakeGraph();\n                disconnectOutputsGraph();\n            }\n            isConnected = false;\n        };\n        connectFakeGraph();\n        return monitorConnections(nativeAudioWorkletNodeFaker, whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=native-audio-worklet-node-faker-factory.js.map"]},"metadata":{},"sourceType":"module"}