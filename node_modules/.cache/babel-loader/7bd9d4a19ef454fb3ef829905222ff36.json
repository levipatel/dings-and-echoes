{"ast":null,"code":"import _classCallCheck from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _get from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { ToneWithContext } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { StateTimeline } from \"../util/StateTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { TickSignal } from \"./TickSignal\";\nimport { EQ } from \"../util/Math\";\n/**\n * Uses [TickSignal](TickSignal) to track elapsed ticks with complex automation curves.\n */\n\nexport var TickSource = /*#__PURE__*/function (_ToneWithContext) {\n  _inherits(TickSource, _ToneWithContext);\n\n  var _super = _createSuper(TickSource);\n\n  function TickSource() {\n    var _this;\n\n    _classCallCheck(this, TickSource);\n\n    _this = _super.call(this, optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]));\n    _this.name = \"TickSource\";\n    /**\n     * The state timeline\n     */\n\n    _this._state = new StateTimeline();\n    /**\n     * The offset values of the ticks\n     */\n\n    _this._tickOffset = new Timeline();\n    var options = optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]);\n    _this.frequency = new TickSignal({\n      context: _this.context,\n      units: options.units,\n      value: options.frequency\n    });\n    readOnly(_assertThisInitialized(_this), \"frequency\"); // set the initial state\n\n    _this._state.setStateAtTime(\"stopped\", 0); // add the first event\n\n\n    _this.setTicksAtTime(0, 0);\n\n    return _this;\n  }\n\n  _createClass(TickSource, [{\n    key: \"start\",\n\n    /**\n     * Start the clock at the given time. Optionally pass in an offset\n     * of where to start the tick counter from.\n     * @param  time    The time the clock should start\n     * @param offset The number of ticks to start the source at\n     */\n    value: function start(time, offset) {\n      var computedTime = this.toSeconds(time);\n\n      if (this._state.getValueAtTime(computedTime) !== \"started\") {\n        this._state.setStateAtTime(\"started\", computedTime);\n\n        if (isDefined(offset)) {\n          this.setTicksAtTime(offset, computedTime);\n        }\n      }\n\n      return this;\n    }\n    /**\n     * Stop the clock. Stopping the clock resets the tick counter to 0.\n     * @param time The time when the clock should stop.\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop(time) {\n      var computedTime = this.toSeconds(time); // cancel the previous stop\n\n      if (this._state.getValueAtTime(computedTime) === \"stopped\") {\n        var event = this._state.get(computedTime);\n\n        if (event && event.time > 0) {\n          this._tickOffset.cancel(event.time);\n\n          this._state.cancel(event.time);\n        }\n      }\n\n      this._state.cancel(computedTime);\n\n      this._state.setStateAtTime(\"stopped\", computedTime);\n\n      this.setTicksAtTime(0, computedTime);\n      return this;\n    }\n    /**\n     * Pause the clock. Pausing does not reset the tick counter.\n     * @param time The time when the clock should stop.\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause(time) {\n      var computedTime = this.toSeconds(time);\n\n      if (this._state.getValueAtTime(computedTime) === \"started\") {\n        this._state.setStateAtTime(\"paused\", computedTime);\n      }\n\n      return this;\n    }\n    /**\n     * Cancel start/stop/pause and setTickAtTime events scheduled after the given time.\n     * @param time When to clear the events after\n     */\n\n  }, {\n    key: \"cancel\",\n    value: function cancel(time) {\n      time = this.toSeconds(time);\n\n      this._state.cancel(time);\n\n      this._tickOffset.cancel(time);\n\n      return this;\n    }\n    /**\n     * Get the elapsed ticks at the given time\n     * @param  time  When to get the tick value\n     * @return The number of ticks\n     */\n\n  }, {\n    key: \"getTicksAtTime\",\n    value: function getTicksAtTime(time) {\n      var _this2 = this;\n\n      var computedTime = this.toSeconds(time);\n\n      var stopEvent = this._state.getLastState(\"stopped\", computedTime); // this event allows forEachBetween to iterate until the current time\n\n\n      var tmpEvent = {\n        state: \"paused\",\n        time: computedTime\n      };\n\n      this._state.add(tmpEvent); // keep track of the previous offset event\n\n\n      var lastState = stopEvent;\n      var elapsedTicks = 0; // iterate through all the events since the last stop\n\n      this._state.forEachBetween(stopEvent.time, computedTime + this.sampleTime, function (e) {\n        var periodStartTime = lastState.time; // if there is an offset event in this period use that\n\n        var offsetEvent = _this2._tickOffset.get(e.time);\n\n        if (offsetEvent && offsetEvent.time >= lastState.time) {\n          elapsedTicks = offsetEvent.ticks;\n          periodStartTime = offsetEvent.time;\n        }\n\n        if (lastState.state === \"started\" && e.state !== \"started\") {\n          elapsedTicks += _this2.frequency.getTicksAtTime(e.time) - _this2.frequency.getTicksAtTime(periodStartTime);\n        }\n\n        lastState = e;\n      }); // remove the temporary event\n\n\n      this._state.remove(tmpEvent); // return the ticks\n\n\n      return elapsedTicks;\n    }\n    /**\n     * The number of times the callback was invoked. Starts counting at 0\n     * and increments after the callback was invoked. Returns -1 when stopped.\n     */\n\n  }, {\n    key: \"getSecondsAtTime\",\n\n    /**\n     * Return the elapsed seconds at the given time.\n     * @param  time  When to get the elapsed seconds\n     * @return  The number of elapsed seconds\n     */\n    value: function getSecondsAtTime(time) {\n      var _this3 = this;\n\n      time = this.toSeconds(time);\n\n      var stopEvent = this._state.getLastState(\"stopped\", time); // this event allows forEachBetween to iterate until the current time\n\n\n      var tmpEvent = {\n        state: \"paused\",\n        time: time\n      };\n\n      this._state.add(tmpEvent); // keep track of the previous offset event\n\n\n      var lastState = stopEvent;\n      var elapsedSeconds = 0; // iterate through all the events since the last stop\n\n      this._state.forEachBetween(stopEvent.time, time + this.sampleTime, function (e) {\n        var periodStartTime = lastState.time; // if there is an offset event in this period use that\n\n        var offsetEvent = _this3._tickOffset.get(e.time);\n\n        if (offsetEvent && offsetEvent.time >= lastState.time) {\n          elapsedSeconds = offsetEvent.seconds;\n          periodStartTime = offsetEvent.time;\n        }\n\n        if (lastState.state === \"started\" && e.state !== \"started\") {\n          elapsedSeconds += e.time - periodStartTime;\n        }\n\n        lastState = e;\n      }); // remove the temporary event\n\n\n      this._state.remove(tmpEvent); // return the ticks\n\n\n      return elapsedSeconds;\n    }\n    /**\n     * Set the clock's ticks at the given time.\n     * @param  ticks The tick value to set\n     * @param  time  When to set the tick value\n     */\n\n  }, {\n    key: \"setTicksAtTime\",\n    value: function setTicksAtTime(ticks, time) {\n      time = this.toSeconds(time);\n\n      this._tickOffset.cancel(time);\n\n      this._tickOffset.add({\n        seconds: this.frequency.getDurationOfTicks(ticks, time),\n        ticks: ticks,\n        time: time\n      });\n\n      return this;\n    }\n    /**\n     * Returns the scheduled state at the given time.\n     * @param  time  The time to query.\n     */\n\n  }, {\n    key: \"getStateAtTime\",\n    value: function getStateAtTime(time) {\n      time = this.toSeconds(time);\n      return this._state.getValueAtTime(time);\n    }\n    /**\n     * Get the time of the given tick. The second argument\n     * is when to test before. Since ticks can be set (with setTicksAtTime)\n     * there may be multiple times for a given tick value.\n     * @param  tick The tick number.\n     * @param  before When to measure the tick value from.\n     * @return The time of the tick\n     */\n\n  }, {\n    key: \"getTimeOfTick\",\n    value: function getTimeOfTick(tick) {\n      var before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.now();\n\n      var offset = this._tickOffset.get(before);\n\n      var event = this._state.get(before);\n\n      var startTime = Math.max(offset.time, event.time);\n      var absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;\n      return this.frequency.getTimeOfTick(absoluteTicks);\n    }\n    /**\n     * Invoke the callback event at all scheduled ticks between the\n     * start time and the end time\n     * @param  startTime  The beginning of the search range\n     * @param  endTime    The end of the search range\n     * @param  callback   The callback to invoke with each tick\n     */\n\n  }, {\n    key: \"forEachTickBetween\",\n    value: function forEachTickBetween(startTime, endTime, callback) {\n      var _this4 = this;\n\n      // only iterate through the sections where it is \"started\"\n      var lastStateEvent = this._state.get(startTime);\n\n      this._state.forEachBetween(startTime, endTime, function (event) {\n        if (lastStateEvent && lastStateEvent.state === \"started\" && event.state !== \"started\") {\n          _this4.forEachTickBetween(Math.max(lastStateEvent.time, startTime), event.time - _this4.sampleTime, callback);\n        }\n\n        lastStateEvent = event;\n      });\n\n      var error = null;\n\n      if (lastStateEvent && lastStateEvent.state === \"started\") {\n        var maxStartTime = Math.max(lastStateEvent.time, startTime); // figure out the difference between the frequency ticks and the\n\n        var startTicks = this.frequency.getTicksAtTime(maxStartTime);\n        var ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);\n        var diff = startTicks - ticksAtStart;\n        var offset = Math.ceil(diff) - diff; // guard against floating point issues\n\n        offset = EQ(offset, 1) ? 0 : offset;\n        var nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);\n\n        while (nextTickTime < endTime) {\n          try {\n            callback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));\n          } catch (e) {\n            error = e;\n            break;\n          }\n\n          nextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);\n        }\n      }\n\n      if (error) {\n        throw error;\n      }\n\n      return this;\n    }\n    /**\n     * Clean up\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(TickSource.prototype), \"dispose\", this).call(this);\n\n      this._state.dispose();\n\n      this._tickOffset.dispose();\n\n      this.frequency.dispose();\n      return this;\n    }\n  }, {\n    key: \"state\",\n\n    /**\n     * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n     */\n    get: function get() {\n      return this.getStateAtTime(this.now());\n    }\n  }, {\n    key: \"ticks\",\n    get: function get() {\n      return this.getTicksAtTime(this.now());\n    },\n    set: function set(t) {\n      this.setTicksAtTime(t, this.now());\n    }\n    /**\n     * The time since ticks=0 that the TickSource has been running. Accounts\n     * for tempo curves\n     */\n\n  }, {\n    key: \"seconds\",\n    get: function get() {\n      return this.getSecondsAtTime(this.now());\n    },\n    set: function set(s) {\n      var now = this.now();\n      var ticks = this.frequency.timeToTicks(s, now);\n      this.setTicksAtTime(ticks, now);\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign({\n        frequency: 1,\n        units: \"hertz\"\n      }, ToneWithContext.getDefaults());\n    }\n  }]);\n\n  return TickSource;\n}(ToneWithContext);","map":{"version":3,"sources":["../../../../Tone/core/clock/TickSource.ts"],"names":[],"mappings":";;;;;;;AAAA,SAAS,eAAT,QAAwD,4BAAxD;AAEA,SAAS,oBAAT,QAAqC,kBAArC;AACA,SAAS,QAAT,QAAyB,mBAAzB;AACA,SAAwB,aAAxB,QAAiE,uBAAjE;AACA,SAAS,QAAT,QAAyB,kBAAzB;AACA,SAAS,SAAT,QAA0B,mBAA1B;AACA,SAAS,UAAT,QAA2B,cAA3B;AACA,SAAS,EAAT,QAAmB,cAAnB;AAaA;;;;AAGA,WAAa,UAAb;AAAA;;AAAA;;AAwBC,wBAAA;AAAA;;AAAA;;AACC,8BAAM,oBAAoB,CAAC,UAAU,CAAC,WAAX,EAAD,EAA2B,SAA3B,EAAsC,CAAC,WAAD,CAAtC,CAA1B;AAvBQ,UAAA,IAAA,GAAe,YAAf;AAOT;;;;AAGQ,UAAA,MAAA,GAAwB,IAAI,aAAJ,EAAxB;AAER;;;;AAGQ,UAAA,WAAA,GAA+C,IAAI,QAAJ,EAA/C;AASP,QAAM,OAAO,GAAG,oBAAoB,CAAC,UAAU,CAAC,WAAX,EAAD,EAA2B,SAA3B,EAAsC,CAAC,WAAD,CAAtC,CAApC;AAEA,UAAK,SAAL,GAAiB,IAAI,UAAJ,CAAe;AAC/B,MAAA,OAAO,EAAE,MAAK,OADiB;AAE/B,MAAA,KAAK,EAAE,OAAO,CAAC,KAFgB;AAG/B,MAAA,KAAK,EAAE,OAAO,CAAC;AAHgB,KAAf,CAAjB;AAKA,IAAA,QAAQ,gCAAO,WAAP,CAAR,CATD,CAWC;;AACA,UAAK,MAAL,CAAY,cAAZ,CAA2B,SAA3B,EAAsC,CAAtC,EAZD,CAaC;;;AACA,UAAK,cAAL,CAAoB,CAApB,EAAuB,CAAvB;;AAdD;AAeC;;AAvCF;AAAA;;AAuDC;;;;;;AAvDD,0BA6DO,IA7DP,EA6DmB,MA7DnB,EA6DiC;AAC/B,UAAM,YAAY,GAAG,KAAK,SAAL,CAAe,IAAf,CAArB;;AACA,UAAI,KAAK,MAAL,CAAY,cAAZ,CAA2B,YAA3B,MAA6C,SAAjD,EAA4D;AAC3D,aAAK,MAAL,CAAY,cAAZ,CAA2B,SAA3B,EAAsC,YAAtC;;AACA,YAAI,SAAS,CAAC,MAAD,CAAb,EAAuB;AACtB,eAAK,cAAL,CAAoB,MAApB,EAA4B,YAA5B;AACA;AACD;;AACD,aAAO,IAAP;AACA;AAED;;;;;AAxED;AAAA;AAAA,yBA4EM,IA5EN,EA4EgB;AACd,UAAM,YAAY,GAAG,KAAK,SAAL,CAAe,IAAf,CAArB,CADc,CAEd;;AACA,UAAI,KAAK,MAAL,CAAY,cAAZ,CAA2B,YAA3B,MAA6C,SAAjD,EAA4D;AAC3D,YAAM,KAAK,GAAG,KAAK,MAAL,CAAY,GAAZ,CAAgB,YAAhB,CAAd;;AACA,YAAI,KAAK,IAAI,KAAK,CAAC,IAAN,GAAa,CAA1B,EAA6B;AAC5B,eAAK,WAAL,CAAiB,MAAjB,CAAwB,KAAK,CAAC,IAA9B;;AACA,eAAK,MAAL,CAAY,MAAZ,CAAmB,KAAK,CAAC,IAAzB;AACA;AACD;;AACD,WAAK,MAAL,CAAY,MAAZ,CAAmB,YAAnB;;AACA,WAAK,MAAL,CAAY,cAAZ,CAA2B,SAA3B,EAAsC,YAAtC;;AACA,WAAK,cAAL,CAAoB,CAApB,EAAuB,YAAvB;AACA,aAAO,IAAP;AACA;AAED;;;;;AA5FD;AAAA;AAAA,0BAgGO,IAhGP,EAgGiB;AACf,UAAM,YAAY,GAAG,KAAK,SAAL,CAAe,IAAf,CAArB;;AACA,UAAI,KAAK,MAAL,CAAY,cAAZ,CAA2B,YAA3B,MAA6C,SAAjD,EAA4D;AAC3D,aAAK,MAAL,CAAY,cAAZ,CAA2B,QAA3B,EAAqC,YAArC;AACA;;AACD,aAAO,IAAP;AACA;AAED;;;;;AAxGD;AAAA;AAAA,2BA4GQ,IA5GR,EA4GkB;AAChB,MAAA,IAAI,GAAG,KAAK,SAAL,CAAe,IAAf,CAAP;;AACA,WAAK,MAAL,CAAY,MAAZ,CAAmB,IAAnB;;AACA,WAAK,WAAL,CAAiB,MAAjB,CAAwB,IAAxB;;AACA,aAAO,IAAP;AACA;AAED;;;;;;AAnHD;AAAA;AAAA,mCAwHgB,IAxHhB,EAwH2B;AAAA;;AACzB,UAAM,YAAY,GAAG,KAAK,SAAL,CAAe,IAAf,CAArB;;AACA,UAAM,SAAS,GAAG,KAAK,MAAL,CAAY,YAAZ,CAAyB,SAAzB,EAAoC,YAApC,CAAlB,CAFyB,CAGzB;;;AACA,UAAM,QAAQ,GAAuB;AAAE,QAAA,KAAK,EAAE,QAAT;AAAmB,QAAA,IAAI,EAAE;AAAzB,OAArC;;AACA,WAAK,MAAL,CAAY,GAAZ,CAAgB,QAAhB,EALyB,CAOzB;;;AACA,UAAI,SAAS,GAAG,SAAhB;AACA,UAAI,YAAY,GAAG,CAAnB,CATyB,CAWzB;;AACA,WAAK,MAAL,CAAY,cAAZ,CAA2B,SAAS,CAAC,IAArC,EAA2C,YAAY,GAAG,KAAK,UAA/D,EAA2E,UAAA,CAAC,EAAG;AAC9E,YAAI,eAAe,GAAG,SAAS,CAAC,IAAhC,CAD8E,CAE9E;;AACA,YAAM,WAAW,GAAG,MAAI,CAAC,WAAL,CAAiB,GAAjB,CAAqB,CAAC,CAAC,IAAvB,CAApB;;AACA,YAAI,WAAW,IAAI,WAAW,CAAC,IAAZ,IAAoB,SAAS,CAAC,IAAjD,EAAuD;AACtD,UAAA,YAAY,GAAG,WAAW,CAAC,KAA3B;AACA,UAAA,eAAe,GAAG,WAAW,CAAC,IAA9B;AACA;;AACD,YAAI,SAAS,CAAC,KAAV,KAAoB,SAApB,IAAiC,CAAC,CAAC,KAAF,KAAY,SAAjD,EAA4D;AAC3D,UAAA,YAAY,IAAI,MAAI,CAAC,SAAL,CAAe,cAAf,CAA8B,CAAC,CAAC,IAAhC,IAAwC,MAAI,CAAC,SAAL,CAAe,cAAf,CAA8B,eAA9B,CAAxD;AACA;;AACD,QAAA,SAAS,GAAG,CAAZ;AACA,OAZD,EAZyB,CA0BzB;;;AACA,WAAK,MAAL,CAAY,MAAZ,CAAmB,QAAnB,EA3ByB,CA6BzB;;;AACA,aAAO,YAAP;AACA;AAED;;;;;AAzJD;AAAA;;AAiLC;;;;;AAjLD,qCAsLkB,IAtLlB,EAsL4B;AAAA;;AAC1B,MAAA,IAAI,GAAG,KAAK,SAAL,CAAe,IAAf,CAAP;;AACA,UAAM,SAAS,GAAG,KAAK,MAAL,CAAY,YAAZ,CAAyB,SAAzB,EAAoC,IAApC,CAAlB,CAF0B,CAG1B;;;AACA,UAAM,QAAQ,GAAuB;AAAE,QAAA,KAAK,EAAE,QAAT;AAAmB,QAAA,IAAI,EAAJ;AAAnB,OAArC;;AACA,WAAK,MAAL,CAAY,GAAZ,CAAgB,QAAhB,EAL0B,CAO1B;;;AACA,UAAI,SAAS,GAAG,SAAhB;AACA,UAAI,cAAc,GAAG,CAArB,CAT0B,CAW1B;;AACA,WAAK,MAAL,CAAY,cAAZ,CAA2B,SAAS,CAAC,IAArC,EAA2C,IAAI,GAAG,KAAK,UAAvD,EAAmE,UAAA,CAAC,EAAG;AACtE,YAAI,eAAe,GAAG,SAAS,CAAC,IAAhC,CADsE,CAEtE;;AACA,YAAM,WAAW,GAAG,MAAI,CAAC,WAAL,CAAiB,GAAjB,CAAqB,CAAC,CAAC,IAAvB,CAApB;;AACA,YAAI,WAAW,IAAI,WAAW,CAAC,IAAZ,IAAoB,SAAS,CAAC,IAAjD,EAAuD;AACtD,UAAA,cAAc,GAAG,WAAW,CAAC,OAA7B;AACA,UAAA,eAAe,GAAG,WAAW,CAAC,IAA9B;AACA;;AACD,YAAI,SAAS,CAAC,KAAV,KAAoB,SAApB,IAAiC,CAAC,CAAC,KAAF,KAAY,SAAjD,EAA4D;AAC3D,UAAA,cAAc,IAAI,CAAC,CAAC,IAAF,GAAS,eAA3B;AACA;;AACD,QAAA,SAAS,GAAG,CAAZ;AACA,OAZD,EAZ0B,CA0B1B;;;AACA,WAAK,MAAL,CAAY,MAAZ,CAAmB,QAAnB,EA3B0B,CA6B1B;;;AACA,aAAO,cAAP;AACA;AAED;;;;;;AAvND;AAAA;AAAA,mCA4NgB,KA5NhB,EA4N8B,IA5N9B,EA4NwC;AACtC,MAAA,IAAI,GAAG,KAAK,SAAL,CAAe,IAAf,CAAP;;AACA,WAAK,WAAL,CAAiB,MAAjB,CAAwB,IAAxB;;AACA,WAAK,WAAL,CAAiB,GAAjB,CAAqB;AACpB,QAAA,OAAO,EAAE,KAAK,SAAL,CAAe,kBAAf,CAAkC,KAAlC,EAAyC,IAAzC,CADW;AAEpB,QAAA,KAAK,EAAL,KAFoB;AAGpB,QAAA,IAAI,EAAJ;AAHoB,OAArB;;AAKA,aAAO,IAAP;AACA;AAED;;;;;AAvOD;AAAA;AAAA,mCA2OgB,IA3OhB,EA2O0B;AACxB,MAAA,IAAI,GAAG,KAAK,SAAL,CAAe,IAAf,CAAP;AACA,aAAO,KAAK,MAAL,CAAY,cAAZ,CAA2B,IAA3B,CAAP;AACA;AAED;;;;;;;;;AAhPD;AAAA;AAAA,kCAwPe,IAxPf,EAwP+C;AAAA,UAAnB,MAAmB,uEAAV,KAAK,GAAL,EAAU;;AAC7C,UAAM,MAAM,GAAG,KAAK,WAAL,CAAiB,GAAjB,CAAqB,MAArB,CAAf;;AACA,UAAM,KAAK,GAAG,KAAK,MAAL,CAAY,GAAZ,CAAgB,MAAhB,CAAd;;AACA,UAAM,SAAS,GAAG,IAAI,CAAC,GAAL,CAAS,MAAM,CAAC,IAAhB,EAAsB,KAAK,CAAC,IAA5B,CAAlB;AACA,UAAM,aAAa,GAAG,KAAK,SAAL,CAAe,cAAf,CAA8B,SAA9B,IAA2C,IAA3C,GAAkD,MAAM,CAAC,KAA/E;AACA,aAAO,KAAK,SAAL,CAAe,aAAf,CAA6B,aAA7B,CAAP;AACA;AAED;;;;;;;;AAhQD;AAAA;AAAA,uCAuQoB,SAvQpB,EAuQuC,OAvQvC,EAuQwD,QAvQxD,EAuQuG;AAAA;;AACrG;AACA,UAAI,cAAc,GAAG,KAAK,MAAL,CAAY,GAAZ,CAAgB,SAAhB,CAArB;;AACA,WAAK,MAAL,CAAY,cAAZ,CAA2B,SAA3B,EAAsC,OAAtC,EAA+C,UAAA,KAAK,EAAG;AACtD,YAAI,cAAc,IAAI,cAAc,CAAC,KAAf,KAAyB,SAA3C,IAAwD,KAAK,CAAC,KAAN,KAAgB,SAA5E,EAAuF;AACtF,UAAA,MAAI,CAAC,kBAAL,CAAwB,IAAI,CAAC,GAAL,CAAS,cAAc,CAAC,IAAxB,EAA8B,SAA9B,CAAxB,EAAkE,KAAK,CAAC,IAAN,GAAa,MAAI,CAAC,UAApF,EAAgG,QAAhG;AACA;;AACD,QAAA,cAAc,GAAG,KAAjB;AACA,OALD;;AAOA,UAAI,KAAK,GAAiB,IAA1B;;AAEA,UAAI,cAAc,IAAI,cAAc,CAAC,KAAf,KAAyB,SAA/C,EAA0D;AACzD,YAAM,YAAY,GAAG,IAAI,CAAC,GAAL,CAAS,cAAc,CAAC,IAAxB,EAA8B,SAA9B,CAArB,CADyD,CAEzD;;AACA,YAAM,UAAU,GAAG,KAAK,SAAL,CAAe,cAAf,CAA8B,YAA9B,CAAnB;AACA,YAAM,YAAY,GAAG,KAAK,SAAL,CAAe,cAAf,CAA8B,cAAc,CAAC,IAA7C,CAArB;AACA,YAAM,IAAI,GAAG,UAAU,GAAG,YAA1B;AACA,YAAI,MAAM,GAAG,IAAI,CAAC,IAAL,CAAU,IAAV,IAAkB,IAA/B,CANyD,CAOzD;;AACA,QAAA,MAAM,GAAG,EAAE,CAAC,MAAD,EAAS,CAAT,CAAF,GAAgB,CAAhB,GAAoB,MAA7B;AACA,YAAI,YAAY,GAAG,KAAK,SAAL,CAAe,aAAf,CAA6B,UAAU,GAAG,MAA1C,CAAnB;;AACA,eAAO,YAAY,GAAG,OAAtB,EAA+B;AAC9B,cAAI;AACH,YAAA,QAAQ,CAAC,YAAD,EAAe,IAAI,CAAC,KAAL,CAAW,KAAK,cAAL,CAAoB,YAApB,CAAX,CAAf,CAAR;AACA,WAFD,CAEE,OAAO,CAAP,EAAU;AACX,YAAA,KAAK,GAAG,CAAR;AACA;AACA;;AACD,UAAA,YAAY,IAAI,KAAK,SAAL,CAAe,kBAAf,CAAkC,CAAlC,EAAqC,YAArC,CAAhB;AACA;AACD;;AAED,UAAI,KAAJ,EAAW;AACV,cAAM,KAAN;AACA;;AAED,aAAO,IAAP;AACA;AAED;;;;AA/SD;AAAA;AAAA,8BAkTQ;AACN;;AACA,WAAK,MAAL,CAAY,OAAZ;;AACA,WAAK,WAAL,CAAiB,OAAjB;;AACA,WAAK,SAAL,CAAe,OAAf;AACA,aAAO,IAAP;AACA;AAxTF;AAAA;;AAgDC;;;AAhDD,wBAmDU;AACR,aAAO,KAAK,cAAL,CAAoB,KAAK,GAAL,EAApB,CAAP;AACA;AArDF;AAAA;AAAA,wBA6JU;AACR,aAAO,KAAK,cAAL,CAAoB,KAAK,GAAL,EAApB,CAAP;AACA,KA/JF;AAAA,sBAgKW,CAhKX,EAgKmB;AACjB,WAAK,cAAL,CAAoB,CAApB,EAAuB,KAAK,GAAL,EAAvB;AACA;AAED;;;;;AApKD;AAAA;AAAA,wBAwKY;AACV,aAAO,KAAK,gBAAL,CAAsB,KAAK,GAAL,EAAtB,CAAP;AACA,KA1KF;AAAA,sBA2Ka,CA3Kb,EA2KuB;AACrB,UAAM,GAAG,GAAG,KAAK,GAAL,EAAZ;AACA,UAAM,KAAK,GAAG,KAAK,SAAL,CAAe,WAAf,CAA2B,CAA3B,EAA8B,GAA9B,CAAd;AACA,WAAK,cAAL,CAAoB,KAApB,EAA2B,GAA3B;AACA;AA/KF;AAAA;AAAA,kCAyCmB;AACjB,aAAO,MAAM,CAAC,MAAP,CAAc;AACpB,QAAA,SAAS,EAAE,CADS;AAEpB,QAAA,KAAK,EAAE;AAFa,OAAd,EAGJ,eAAe,CAAC,WAAhB,EAHI,CAAP;AAIA;AA9CF;;AAAA;AAAA,EAAkE,eAAlE","sourceRoot":"","sourcesContent":["import { ToneWithContext } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { StateTimeline } from \"../util/StateTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { TickSignal } from \"./TickSignal\";\nimport { EQ } from \"../util/Math\";\n/**\n * Uses [TickSignal](TickSignal) to track elapsed ticks with complex automation curves.\n */\nexport class TickSource extends ToneWithContext {\n    constructor() {\n        super(optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]));\n        this.name = \"TickSource\";\n        /**\n         * The state timeline\n         */\n        this._state = new StateTimeline();\n        /**\n         * The offset values of the ticks\n         */\n        this._tickOffset = new Timeline();\n        const options = optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]);\n        this.frequency = new TickSignal({\n            context: this.context,\n            units: options.units,\n            value: options.frequency,\n        });\n        readOnly(this, \"frequency\");\n        // set the initial state\n        this._state.setStateAtTime(\"stopped\", 0);\n        // add the first event\n        this.setTicksAtTime(0, 0);\n    }\n    static getDefaults() {\n        return Object.assign({\n            frequency: 1,\n            units: \"hertz\",\n        }, ToneWithContext.getDefaults());\n    }\n    /**\n     * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n     */\n    get state() {\n        return this.getStateAtTime(this.now());\n    }\n    /**\n     * Start the clock at the given time. Optionally pass in an offset\n     * of where to start the tick counter from.\n     * @param  time    The time the clock should start\n     * @param offset The number of ticks to start the source at\n     */\n    start(time, offset) {\n        const computedTime = this.toSeconds(time);\n        if (this._state.getValueAtTime(computedTime) !== \"started\") {\n            this._state.setStateAtTime(\"started\", computedTime);\n            if (isDefined(offset)) {\n                this.setTicksAtTime(offset, computedTime);\n            }\n        }\n        return this;\n    }\n    /**\n     * Stop the clock. Stopping the clock resets the tick counter to 0.\n     * @param time The time when the clock should stop.\n     */\n    stop(time) {\n        const computedTime = this.toSeconds(time);\n        // cancel the previous stop\n        if (this._state.getValueAtTime(computedTime) === \"stopped\") {\n            const event = this._state.get(computedTime);\n            if (event && event.time > 0) {\n                this._tickOffset.cancel(event.time);\n                this._state.cancel(event.time);\n            }\n        }\n        this._state.cancel(computedTime);\n        this._state.setStateAtTime(\"stopped\", computedTime);\n        this.setTicksAtTime(0, computedTime);\n        return this;\n    }\n    /**\n     * Pause the clock. Pausing does not reset the tick counter.\n     * @param time The time when the clock should stop.\n     */\n    pause(time) {\n        const computedTime = this.toSeconds(time);\n        if (this._state.getValueAtTime(computedTime) === \"started\") {\n            this._state.setStateAtTime(\"paused\", computedTime);\n        }\n        return this;\n    }\n    /**\n     * Cancel start/stop/pause and setTickAtTime events scheduled after the given time.\n     * @param time When to clear the events after\n     */\n    cancel(time) {\n        time = this.toSeconds(time);\n        this._state.cancel(time);\n        this._tickOffset.cancel(time);\n        return this;\n    }\n    /**\n     * Get the elapsed ticks at the given time\n     * @param  time  When to get the tick value\n     * @return The number of ticks\n     */\n    getTicksAtTime(time) {\n        const computedTime = this.toSeconds(time);\n        const stopEvent = this._state.getLastState(\"stopped\", computedTime);\n        // this event allows forEachBetween to iterate until the current time\n        const tmpEvent = { state: \"paused\", time: computedTime };\n        this._state.add(tmpEvent);\n        // keep track of the previous offset event\n        let lastState = stopEvent;\n        let elapsedTicks = 0;\n        // iterate through all the events since the last stop\n        this._state.forEachBetween(stopEvent.time, computedTime + this.sampleTime, e => {\n            let periodStartTime = lastState.time;\n            // if there is an offset event in this period use that\n            const offsetEvent = this._tickOffset.get(e.time);\n            if (offsetEvent && offsetEvent.time >= lastState.time) {\n                elapsedTicks = offsetEvent.ticks;\n                periodStartTime = offsetEvent.time;\n            }\n            if (lastState.state === \"started\" && e.state !== \"started\") {\n                elapsedTicks += this.frequency.getTicksAtTime(e.time) - this.frequency.getTicksAtTime(periodStartTime);\n            }\n            lastState = e;\n        });\n        // remove the temporary event\n        this._state.remove(tmpEvent);\n        // return the ticks\n        return elapsedTicks;\n    }\n    /**\n     * The number of times the callback was invoked. Starts counting at 0\n     * and increments after the callback was invoked. Returns -1 when stopped.\n     */\n    get ticks() {\n        return this.getTicksAtTime(this.now());\n    }\n    set ticks(t) {\n        this.setTicksAtTime(t, this.now());\n    }\n    /**\n     * The time since ticks=0 that the TickSource has been running. Accounts\n     * for tempo curves\n     */\n    get seconds() {\n        return this.getSecondsAtTime(this.now());\n    }\n    set seconds(s) {\n        const now = this.now();\n        const ticks = this.frequency.timeToTicks(s, now);\n        this.setTicksAtTime(ticks, now);\n    }\n    /**\n     * Return the elapsed seconds at the given time.\n     * @param  time  When to get the elapsed seconds\n     * @return  The number of elapsed seconds\n     */\n    getSecondsAtTime(time) {\n        time = this.toSeconds(time);\n        const stopEvent = this._state.getLastState(\"stopped\", time);\n        // this event allows forEachBetween to iterate until the current time\n        const tmpEvent = { state: \"paused\", time };\n        this._state.add(tmpEvent);\n        // keep track of the previous offset event\n        let lastState = stopEvent;\n        let elapsedSeconds = 0;\n        // iterate through all the events since the last stop\n        this._state.forEachBetween(stopEvent.time, time + this.sampleTime, e => {\n            let periodStartTime = lastState.time;\n            // if there is an offset event in this period use that\n            const offsetEvent = this._tickOffset.get(e.time);\n            if (offsetEvent && offsetEvent.time >= lastState.time) {\n                elapsedSeconds = offsetEvent.seconds;\n                periodStartTime = offsetEvent.time;\n            }\n            if (lastState.state === \"started\" && e.state !== \"started\") {\n                elapsedSeconds += e.time - periodStartTime;\n            }\n            lastState = e;\n        });\n        // remove the temporary event\n        this._state.remove(tmpEvent);\n        // return the ticks\n        return elapsedSeconds;\n    }\n    /**\n     * Set the clock's ticks at the given time.\n     * @param  ticks The tick value to set\n     * @param  time  When to set the tick value\n     */\n    setTicksAtTime(ticks, time) {\n        time = this.toSeconds(time);\n        this._tickOffset.cancel(time);\n        this._tickOffset.add({\n            seconds: this.frequency.getDurationOfTicks(ticks, time),\n            ticks,\n            time,\n        });\n        return this;\n    }\n    /**\n     * Returns the scheduled state at the given time.\n     * @param  time  The time to query.\n     */\n    getStateAtTime(time) {\n        time = this.toSeconds(time);\n        return this._state.getValueAtTime(time);\n    }\n    /**\n     * Get the time of the given tick. The second argument\n     * is when to test before. Since ticks can be set (with setTicksAtTime)\n     * there may be multiple times for a given tick value.\n     * @param  tick The tick number.\n     * @param  before When to measure the tick value from.\n     * @return The time of the tick\n     */\n    getTimeOfTick(tick, before = this.now()) {\n        const offset = this._tickOffset.get(before);\n        const event = this._state.get(before);\n        const startTime = Math.max(offset.time, event.time);\n        const absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;\n        return this.frequency.getTimeOfTick(absoluteTicks);\n    }\n    /**\n     * Invoke the callback event at all scheduled ticks between the\n     * start time and the end time\n     * @param  startTime  The beginning of the search range\n     * @param  endTime    The end of the search range\n     * @param  callback   The callback to invoke with each tick\n     */\n    forEachTickBetween(startTime, endTime, callback) {\n        // only iterate through the sections where it is \"started\"\n        let lastStateEvent = this._state.get(startTime);\n        this._state.forEachBetween(startTime, endTime, event => {\n            if (lastStateEvent && lastStateEvent.state === \"started\" && event.state !== \"started\") {\n                this.forEachTickBetween(Math.max(lastStateEvent.time, startTime), event.time - this.sampleTime, callback);\n            }\n            lastStateEvent = event;\n        });\n        let error = null;\n        if (lastStateEvent && lastStateEvent.state === \"started\") {\n            const maxStartTime = Math.max(lastStateEvent.time, startTime);\n            // figure out the difference between the frequency ticks and the\n            const startTicks = this.frequency.getTicksAtTime(maxStartTime);\n            const ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);\n            const diff = startTicks - ticksAtStart;\n            let offset = Math.ceil(diff) - diff;\n            // guard against floating point issues\n            offset = EQ(offset, 1) ? 0 : offset;\n            let nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);\n            while (nextTickTime < endTime) {\n                try {\n                    callback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));\n                }\n                catch (e) {\n                    error = e;\n                    break;\n                }\n                nextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);\n            }\n        }\n        if (error) {\n            throw error;\n        }\n        return this;\n    }\n    /**\n     * Clean up\n     */\n    dispose() {\n        super.dispose();\n        this._state.dispose();\n        this._tickOffset.dispose();\n        this.frequency.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=TickSource.js.map"]},"metadata":{},"sourceType":"module"}