{"ast":null,"code":"import _classCallCheck from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { ToneAudioBuffer } from \"../core/context/ToneAudioBuffer\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { assert } from \"../core/util/Debug\";\nimport { Source } from \"../source/Source\";\nimport { ToneBufferSource } from \"./buffer/ToneBufferSource\";\n/**\n * Noise is a noise generator. It uses looped noise buffers to save on performance.\n * Noise supports the noise types: \"pink\", \"white\", and \"brown\". Read more about\n * colors of noise on [Wikipedia](https://en.wikipedia.org/wiki/Colors_of_noise).\n *\n * @example\n * // initialize the noise and start\n * const noise = new Tone.Noise(\"pink\").start();\n * // make an autofilter to shape the noise\n * const autoFilter = new Tone.AutoFilter({\n * \tfrequency: \"8n\",\n * \tbaseFrequency: 200,\n * \toctaves: 8\n * }).toDestination().start();\n * // connect the noise\n * noise.connect(autoFilter);\n * // start the autofilter LFO\n * autoFilter.start();\n * @category Source\n */\n\nexport var Noise = /*#__PURE__*/function (_Source) {\n  _inherits(Noise, _Source);\n\n  var _super = _createSuper(Noise);\n\n  function Noise() {\n    var _this;\n\n    _classCallCheck(this, Noise);\n\n    _this = _super.call(this, optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]));\n    _this.name = \"Noise\";\n    /**\n     * Private reference to the source\n     */\n\n    _this._source = null;\n    var options = optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]);\n    _this._playbackRate = options.playbackRate;\n    _this.type = options.type;\n    _this._fadeIn = options.fadeIn;\n    _this._fadeOut = options.fadeOut;\n    return _this;\n  }\n\n  _createClass(Noise, [{\n    key: \"_start\",\n\n    /**\n     * internal start method\n     */\n    value: function _start(time) {\n      var _this2 = this;\n\n      var buffer = _noiseBuffers[this._type];\n      this._source = new ToneBufferSource({\n        url: buffer,\n        context: this.context,\n        fadeIn: this._fadeIn,\n        fadeOut: this._fadeOut,\n        loop: true,\n        onended: function onended() {\n          return _this2.onstop(_this2);\n        },\n        playbackRate: this._playbackRate\n      }).connect(this.output);\n\n      this._source.start(this.toSeconds(time), Math.random() * (buffer.duration - 0.001));\n    }\n    /**\n     * internal stop method\n     */\n\n  }, {\n    key: \"_stop\",\n    value: function _stop(time) {\n      if (this._source) {\n        this._source.stop(this.toSeconds(time));\n\n        this._source = null;\n      }\n    }\n    /**\n     * The fadeIn time of the amplitude envelope.\n     */\n\n  }, {\n    key: \"_restart\",\n    value: function _restart(time) {\n      // TODO could be optimized by cancelling the buffer source 'stop'\n      this._stop(time);\n\n      this._start(time);\n    }\n    /**\n     * Clean up.\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Noise.prototype), \"dispose\", this).call(this);\n\n      if (this._source) {\n        this._source.disconnect();\n      }\n\n      return this;\n    }\n  }, {\n    key: \"type\",\n\n    /**\n     * The type of the noise. Can be \"white\", \"brown\", or \"pink\".\n     * @example\n     * const noise = new Tone.Noise().toDestination().start();\n     * noise.type = \"brown\";\n     */\n    get: function get() {\n      return this._type;\n    },\n    set: function set(type) {\n      assert(type in _noiseBuffers, \"Noise: invalid type: \" + type);\n\n      if (this._type !== type) {\n        this._type = type; // if it's playing, stop and restart it\n\n        if (this.state === \"started\") {\n          var now = this.now();\n\n          this._stop(now);\n\n          this._start(now);\n        }\n      }\n    }\n    /**\n     * The playback rate of the noise. Affects\n     * the \"frequency\" of the noise.\n     */\n\n  }, {\n    key: \"playbackRate\",\n    get: function get() {\n      return this._playbackRate;\n    },\n    set: function set(rate) {\n      this._playbackRate = rate;\n\n      if (this._source) {\n        this._source.playbackRate.value = rate;\n      }\n    }\n  }, {\n    key: \"fadeIn\",\n    get: function get() {\n      return this._fadeIn;\n    },\n    set: function set(time) {\n      this._fadeIn = time;\n\n      if (this._source) {\n        this._source.fadeIn = this._fadeIn;\n      }\n    }\n    /**\n     * The fadeOut time of the amplitude envelope.\n     */\n\n  }, {\n    key: \"fadeOut\",\n    get: function get() {\n      return this._fadeOut;\n    },\n    set: function set(time) {\n      this._fadeOut = time;\n\n      if (this._source) {\n        this._source.fadeOut = this._fadeOut;\n      }\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(Source.getDefaults(), {\n        fadeIn: 0,\n        fadeOut: 0,\n        playbackRate: 1,\n        type: \"white\"\n      });\n    }\n  }]);\n\n  return Noise;\n}(Source); //--------------------\n// THE NOISE BUFFERS\n//--------------------\n// Noise buffer stats\n\nvar BUFFER_LENGTH = 44100 * 5;\nvar NUM_CHANNELS = 2;\n/**\n * Cache the noise buffers\n */\n\nvar _noiseCache = {\n  brown: null,\n  pink: null,\n  white: null\n};\n/**\n * The noise arrays. Generated on initialization.\n * borrowed heavily from https://github.com/zacharydenton/noise.js\n * (c) 2013 Zach Denton (MIT)\n */\n\nvar _noiseBuffers = {\n  get brown() {\n    if (!_noiseCache.brown) {\n      var buffer = [];\n\n      for (var channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n        var channel = new Float32Array(BUFFER_LENGTH);\n        buffer[channelNum] = channel;\n        var lastOut = 0.0;\n\n        for (var i = 0; i < BUFFER_LENGTH; i++) {\n          var white = Math.random() * 2 - 1;\n          channel[i] = (lastOut + 0.02 * white) / 1.02;\n          lastOut = channel[i];\n          channel[i] *= 3.5; // (roughly) compensate for gain\n        }\n      }\n\n      _noiseCache.brown = new ToneAudioBuffer().fromArray(buffer);\n    }\n\n    return _noiseCache.brown;\n  },\n\n  get pink() {\n    if (!_noiseCache.pink) {\n      var buffer = [];\n\n      for (var channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n        var channel = new Float32Array(BUFFER_LENGTH);\n        buffer[channelNum] = channel;\n        var b0 = void 0,\n            b1 = void 0,\n            b2 = void 0,\n            b3 = void 0,\n            b4 = void 0,\n            b5 = void 0,\n            b6 = void 0;\n        b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;\n\n        for (var i = 0; i < BUFFER_LENGTH; i++) {\n          var white = Math.random() * 2 - 1;\n          b0 = 0.99886 * b0 + white * 0.0555179;\n          b1 = 0.99332 * b1 + white * 0.0750759;\n          b2 = 0.96900 * b2 + white * 0.1538520;\n          b3 = 0.86650 * b3 + white * 0.3104856;\n          b4 = 0.55000 * b4 + white * 0.5329522;\n          b5 = -0.7616 * b5 - white * 0.0168980;\n          channel[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;\n          channel[i] *= 0.11; // (roughly) compensate for gain\n\n          b6 = white * 0.115926;\n        }\n      }\n\n      _noiseCache.pink = new ToneAudioBuffer().fromArray(buffer);\n    }\n\n    return _noiseCache.pink;\n  },\n\n  get white() {\n    if (!_noiseCache.white) {\n      var buffer = [];\n\n      for (var channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n        var channel = new Float32Array(BUFFER_LENGTH);\n        buffer[channelNum] = channel;\n\n        for (var i = 0; i < BUFFER_LENGTH; i++) {\n          channel[i] = Math.random() * 2 - 1;\n        }\n      }\n\n      _noiseCache.white = new ToneAudioBuffer().fromArray(buffer);\n    }\n\n    return _noiseCache.white;\n  }\n\n};","map":{"version":3,"sources":["../../../Tone/source/Noise.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { ToneAudioBuffer } from \"../core/context/ToneAudioBuffer\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { assert } from \"../core/util/Debug\";\nimport { Source } from \"../source/Source\";\nimport { ToneBufferSource } from \"./buffer/ToneBufferSource\";\n/**\n * Noise is a noise generator. It uses looped noise buffers to save on performance.\n * Noise supports the noise types: \"pink\", \"white\", and \"brown\". Read more about\n * colors of noise on [Wikipedia](https://en.wikipedia.org/wiki/Colors_of_noise).\n *\n * @example\n * // initialize the noise and start\n * const noise = new Tone.Noise(\"pink\").start();\n * // make an autofilter to shape the noise\n * const autoFilter = new Tone.AutoFilter({\n * \tfrequency: \"8n\",\n * \tbaseFrequency: 200,\n * \toctaves: 8\n * }).toDestination().start();\n * // connect the noise\n * noise.connect(autoFilter);\n * // start the autofilter LFO\n * autoFilter.start();\n * @category Source\n */\nexport class Noise extends Source {\n    constructor() {\n        super(optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]));\n        this.name = \"Noise\";\n        /**\n         * Private reference to the source\n         */\n        this._source = null;\n        const options = optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]);\n        this._playbackRate = options.playbackRate;\n        this.type = options.type;\n        this._fadeIn = options.fadeIn;\n        this._fadeOut = options.fadeOut;\n    }\n    static getDefaults() {\n        return Object.assign(Source.getDefaults(), {\n            fadeIn: 0,\n            fadeOut: 0,\n            playbackRate: 1,\n            type: \"white\",\n        });\n    }\n    /**\n     * The type of the noise. Can be \"white\", \"brown\", or \"pink\".\n     * @example\n     * const noise = new Tone.Noise().toDestination().start();\n     * noise.type = \"brown\";\n     */\n    get type() {\n        return this._type;\n    }\n    set type(type) {\n        assert(type in _noiseBuffers, \"Noise: invalid type: \" + type);\n        if (this._type !== type) {\n            this._type = type;\n            // if it's playing, stop and restart it\n            if (this.state === \"started\") {\n                const now = this.now();\n                this._stop(now);\n                this._start(now);\n            }\n        }\n    }\n    /**\n     * The playback rate of the noise. Affects\n     * the \"frequency\" of the noise.\n     */\n    get playbackRate() {\n        return this._playbackRate;\n    }\n    set playbackRate(rate) {\n        this._playbackRate = rate;\n        if (this._source) {\n            this._source.playbackRate.value = rate;\n        }\n    }\n    /**\n     * internal start method\n     */\n    _start(time) {\n        const buffer = _noiseBuffers[this._type];\n        this._source = new ToneBufferSource({\n            url: buffer,\n            context: this.context,\n            fadeIn: this._fadeIn,\n            fadeOut: this._fadeOut,\n            loop: true,\n            onended: () => this.onstop(this),\n            playbackRate: this._playbackRate,\n        }).connect(this.output);\n        this._source.start(this.toSeconds(time), Math.random() * (buffer.duration - 0.001));\n    }\n    /**\n     * internal stop method\n     */\n    _stop(time) {\n        if (this._source) {\n            this._source.stop(this.toSeconds(time));\n            this._source = null;\n        }\n    }\n    /**\n     * The fadeIn time of the amplitude envelope.\n     */\n    get fadeIn() {\n        return this._fadeIn;\n    }\n    set fadeIn(time) {\n        this._fadeIn = time;\n        if (this._source) {\n            this._source.fadeIn = this._fadeIn;\n        }\n    }\n    /**\n     * The fadeOut time of the amplitude envelope.\n     */\n    get fadeOut() {\n        return this._fadeOut;\n    }\n    set fadeOut(time) {\n        this._fadeOut = time;\n        if (this._source) {\n            this._source.fadeOut = this._fadeOut;\n        }\n    }\n    _restart(time) {\n        // TODO could be optimized by cancelling the buffer source 'stop'\n        this._stop(time);\n        this._start(time);\n    }\n    /**\n     * Clean up.\n     */\n    dispose() {\n        super.dispose();\n        if (this._source) {\n            this._source.disconnect();\n        }\n        return this;\n    }\n}\n//--------------------\n// THE NOISE BUFFERS\n//--------------------\n// Noise buffer stats\nconst BUFFER_LENGTH = 44100 * 5;\nconst NUM_CHANNELS = 2;\n/**\n * Cache the noise buffers\n */\nconst _noiseCache = {\n    brown: null,\n    pink: null,\n    white: null,\n};\n/**\n * The noise arrays. Generated on initialization.\n * borrowed heavily from https://github.com/zacharydenton/noise.js\n * (c) 2013 Zach Denton (MIT)\n */\nconst _noiseBuffers = {\n    get brown() {\n        if (!_noiseCache.brown) {\n            const buffer = [];\n            for (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n                const channel = new Float32Array(BUFFER_LENGTH);\n                buffer[channelNum] = channel;\n                let lastOut = 0.0;\n                for (let i = 0; i < BUFFER_LENGTH; i++) {\n                    const white = Math.random() * 2 - 1;\n                    channel[i] = (lastOut + (0.02 * white)) / 1.02;\n                    lastOut = channel[i];\n                    channel[i] *= 3.5; // (roughly) compensate for gain\n                }\n            }\n            _noiseCache.brown = new ToneAudioBuffer().fromArray(buffer);\n        }\n        return _noiseCache.brown;\n    },\n    get pink() {\n        if (!_noiseCache.pink) {\n            const buffer = [];\n            for (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n                const channel = new Float32Array(BUFFER_LENGTH);\n                buffer[channelNum] = channel;\n                let b0, b1, b2, b3, b4, b5, b6;\n                b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;\n                for (let i = 0; i < BUFFER_LENGTH; i++) {\n                    const white = Math.random() * 2 - 1;\n                    b0 = 0.99886 * b0 + white * 0.0555179;\n                    b1 = 0.99332 * b1 + white * 0.0750759;\n                    b2 = 0.96900 * b2 + white * 0.1538520;\n                    b3 = 0.86650 * b3 + white * 0.3104856;\n                    b4 = 0.55000 * b4 + white * 0.5329522;\n                    b5 = -0.7616 * b5 - white * 0.0168980;\n                    channel[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;\n                    channel[i] *= 0.11; // (roughly) compensate for gain\n                    b6 = white * 0.115926;\n                }\n            }\n            _noiseCache.pink = new ToneAudioBuffer().fromArray(buffer);\n        }\n        return _noiseCache.pink;\n    },\n    get white() {\n        if (!_noiseCache.white) {\n            const buffer = [];\n            for (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n                const channel = new Float32Array(BUFFER_LENGTH);\n                buffer[channelNum] = channel;\n                for (let i = 0; i < BUFFER_LENGTH; i++) {\n                    channel[i] = Math.random() * 2 - 1;\n                }\n            }\n            _noiseCache.white = new ToneAudioBuffer().fromArray(buffer);\n        }\n        return _noiseCache.white;\n    },\n};\n//# sourceMappingURL=Noise.js.map"]},"metadata":{},"sourceType":"module"}