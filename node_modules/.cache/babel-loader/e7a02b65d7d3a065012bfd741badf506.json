{"ast":null,"code":"import _regeneratorRuntime from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _classCallCheck from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _get from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { __awaiter } from \"tslib\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isNumber, isString } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { AMOscillator } from \"./AMOscillator\";\nimport { FatOscillator } from \"./FatOscillator\";\nimport { FMOscillator } from \"./FMOscillator\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform } from \"./OscillatorInterface\";\nimport { PulseOscillator } from \"./PulseOscillator\";\nimport { PWMOscillator } from \"./PWMOscillator\";\nvar OmniOscillatorSourceMap = {\n  am: AMOscillator,\n  fat: FatOscillator,\n  fm: FMOscillator,\n  oscillator: Oscillator,\n  pulse: PulseOscillator,\n  pwm: PWMOscillator\n};\n/**\n * OmniOscillator aggregates all of the oscillator types into one.\n * @example\n * return Tone.Offline(() => {\n * \tconst omniOsc = new Tone.OmniOscillator(\"C#4\", \"pwm\").toDestination().start();\n * }, 0.1, 1);\n * @category Source\n */\n\nexport var OmniOscillator = /*#__PURE__*/function (_Source) {\n  _inherits(OmniOscillator, _Source);\n\n  var _super = _createSuper(OmniOscillator);\n\n  function OmniOscillator() {\n    var _this;\n\n    _classCallCheck(this, OmniOscillator);\n\n    _this = _super.call(this, optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n    _this.name = \"OmniOscillator\";\n    var options = optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n    _this.frequency = new Signal({\n      context: _this.context,\n      units: \"frequency\",\n      value: options.frequency\n    });\n    _this.detune = new Signal({\n      context: _this.context,\n      units: \"cents\",\n      value: options.detune\n    });\n    readOnly(_assertThisInitialized(_this), [\"frequency\", \"detune\"]); // set the options\n\n    _this.set(options);\n\n    return _this;\n  }\n\n  _createClass(OmniOscillator, [{\n    key: \"_start\",\n\n    /**\n     * start the oscillator\n     */\n    value: function _start(time) {\n      this._oscillator.start(time);\n    }\n    /**\n     * start the oscillator\n     */\n\n  }, {\n    key: \"_stop\",\n    value: function _stop(time) {\n      this._oscillator.stop(time);\n    }\n  }, {\n    key: \"_restart\",\n    value: function _restart(time) {\n      this._oscillator.restart(time);\n\n      return this;\n    }\n    /**\n     * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or\n     * prefix the basic types with \"fm\", \"am\", or \"fat\" to use the FMOscillator, AMOscillator or FatOscillator\n     * types. The oscillator could also be set to \"pwm\" or \"pulse\". All of the parameters of the\n     * oscillator's class are accessible when the oscillator is set to that type, but throws an error\n     * when it's not.\n     * @example\n     * const omniOsc = new Tone.OmniOscillator().toDestination().start();\n     * omniOsc.type = \"pwm\";\n     * // modulationFrequency is parameter which is available\n     * // only when the type is \"pwm\".\n     * omniOsc.modulationFrequency.value = 0.5;\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(props) {\n      // make sure the type is set first\n      if (Reflect.has(props, \"type\") && props.type) {\n        this.type = props.type;\n      } // then set the rest\n\n\n      _get(_getPrototypeOf(OmniOscillator.prototype), \"set\", this).call(this, props);\n\n      return this;\n    }\n    /**\n     * connect the oscillator to the frequency and detune signals\n     */\n\n  }, {\n    key: \"_createNewOscillator\",\n    value: function _createNewOscillator(oscType) {\n      var _this2 = this;\n\n      if (oscType !== this._sourceType) {\n        this._sourceType = oscType;\n        var OscConstructor = OmniOscillatorSourceMap[oscType]; // short delay to avoid clicks on the change\n\n        var now = this.now();\n\n        if (this._oscillator) {\n          var oldOsc = this._oscillator;\n          oldOsc.stop(now); // dispose the old one\n\n          this.context.setTimeout(function () {\n            return oldOsc.dispose();\n          }, this.blockTime);\n        }\n\n        this._oscillator = new OscConstructor({\n          context: this.context\n        });\n        this.frequency.connect(this._oscillator.frequency);\n        this.detune.connect(this._oscillator.detune);\n\n        this._oscillator.connect(this.output);\n\n        this._oscillator.onstop = function () {\n          return _this2.onstop(_this2);\n        };\n\n        if (this.state === \"started\") {\n          this._oscillator.start(now);\n        }\n      }\n    }\n  }, {\n    key: \"_getOscType\",\n    value: function _getOscType(osc, sourceType) {\n      return osc instanceof OmniOscillatorSourceMap[sourceType];\n    }\n    /**\n     * The base type of the oscillator. See [[Oscillator.baseType]]\n     * @example\n     * const omniOsc = new Tone.OmniOscillator(440, \"fmsquare4\");\n     * console.log(omniOsc.sourceType, omniOsc.baseType, omniOsc.partialCount);\n     */\n\n  }, {\n    key: \"asArray\",\n    value: function asArray() {\n      var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1024;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", generateWaveform(this, length));\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(OmniOscillator.prototype), \"dispose\", this).call(this);\n\n      this.detune.dispose();\n      this.frequency.dispose();\n\n      this._oscillator.dispose();\n\n      return this;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      var _this3 = this;\n\n      var prefix = \"\";\n\n      if ([\"am\", \"fm\", \"fat\"].some(function (p) {\n        return _this3._sourceType === p;\n      })) {\n        prefix = this._sourceType;\n      }\n\n      return prefix + this._oscillator.type;\n    },\n    set: function set(type) {\n      if (type.substr(0, 2) === \"fm\") {\n        this._createNewOscillator(\"fm\");\n\n        this._oscillator = this._oscillator;\n        this._oscillator.type = type.substr(2);\n      } else if (type.substr(0, 2) === \"am\") {\n        this._createNewOscillator(\"am\");\n\n        this._oscillator = this._oscillator;\n        this._oscillator.type = type.substr(2);\n      } else if (type.substr(0, 3) === \"fat\") {\n        this._createNewOscillator(\"fat\");\n\n        this._oscillator = this._oscillator;\n        this._oscillator.type = type.substr(3);\n      } else if (type === \"pwm\") {\n        this._createNewOscillator(\"pwm\");\n\n        this._oscillator = this._oscillator;\n      } else if (type === \"pulse\") {\n        this._createNewOscillator(\"pulse\");\n      } else {\n        this._createNewOscillator(\"oscillator\");\n\n        this._oscillator = this._oscillator;\n        this._oscillator.type = type;\n      }\n    }\n    /**\n     * The value is an empty array when the type is not \"custom\".\n     * This is not available on \"pwm\" and \"pulse\" oscillator types.\n     * See [[Oscillator.partials]]\n     */\n\n  }, {\n    key: \"partials\",\n    get: function get() {\n      return this._oscillator.partials;\n    },\n    set: function set(partials) {\n      if (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n        this._oscillator.partials = partials;\n      }\n    }\n  }, {\n    key: \"partialCount\",\n    get: function get() {\n      return this._oscillator.partialCount;\n    },\n    set: function set(partialCount) {\n      if (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n        this._oscillator.partialCount = partialCount;\n      }\n    }\n  }, {\n    key: \"phase\",\n    get: function get() {\n      return this._oscillator.phase;\n    },\n    set: function set(phase) {\n      this._oscillator.phase = phase;\n    }\n    /**\n     * The source type of the oscillator.\n     * @example\n     * const omniOsc = new Tone.OmniOscillator(440, \"fmsquare\");\n     * console.log(omniOsc.sourceType); // 'fm'\n     */\n\n  }, {\n    key: \"sourceType\",\n    get: function get() {\n      return this._sourceType;\n    },\n    set: function set(sType) {\n      // the basetype defaults to sine\n      var baseType = \"sine\";\n\n      if (this._oscillator.type !== \"pwm\" && this._oscillator.type !== \"pulse\") {\n        baseType = this._oscillator.type;\n      } // set the type\n\n\n      if (sType === \"fm\") {\n        this.type = \"fm\" + baseType;\n      } else if (sType === \"am\") {\n        this.type = \"am\" + baseType;\n      } else if (sType === \"fat\") {\n        this.type = \"fat\" + baseType;\n      } else if (sType === \"oscillator\") {\n        this.type = baseType;\n      } else if (sType === \"pulse\") {\n        this.type = \"pulse\";\n      } else if (sType === \"pwm\") {\n        this.type = \"pwm\";\n      }\n    }\n  }, {\n    key: \"baseType\",\n    get: function get() {\n      return this._oscillator.baseType;\n    },\n    set: function set(baseType) {\n      if (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\") && baseType !== \"pulse\" && baseType !== \"pwm\") {\n        this._oscillator.baseType = baseType;\n      }\n    }\n    /**\n     * The width of the oscillator when sourceType === \"pulse\".\n     * See [[PWMOscillator.width]]\n     */\n\n  }, {\n    key: \"width\",\n    get: function get() {\n      if (this._getOscType(this._oscillator, \"pulse\")) {\n        return this._oscillator.width;\n      } else {\n        return undefined;\n      }\n    }\n    /**\n     * The number of detuned oscillators when sourceType === \"fat\".\n     * See [[FatOscillator.count]]\n     */\n\n  }, {\n    key: \"count\",\n    get: function get() {\n      if (this._getOscType(this._oscillator, \"fat\")) {\n        return this._oscillator.count;\n      } else {\n        return undefined;\n      }\n    },\n    set: function set(count) {\n      if (this._getOscType(this._oscillator, \"fat\") && isNumber(count)) {\n        this._oscillator.count = count;\n      }\n    }\n    /**\n     * The detune spread between the oscillators when sourceType === \"fat\".\n     * See [[FatOscillator.count]]\n     */\n\n  }, {\n    key: \"spread\",\n    get: function get() {\n      if (this._getOscType(this._oscillator, \"fat\")) {\n        return this._oscillator.spread;\n      } else {\n        return undefined;\n      }\n    },\n    set: function set(spread) {\n      if (this._getOscType(this._oscillator, \"fat\") && isNumber(spread)) {\n        this._oscillator.spread = spread;\n      }\n    }\n    /**\n     * The type of the modulator oscillator. Only if the oscillator is set to \"am\" or \"fm\" types.\n     * See [[AMOscillator]] or [[FMOscillator]]\n     */\n\n  }, {\n    key: \"modulationType\",\n    get: function get() {\n      if (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n        return this._oscillator.modulationType;\n      } else {\n        return undefined;\n      }\n    },\n    set: function set(mType) {\n      if ((this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) && isString(mType)) {\n        this._oscillator.modulationType = mType;\n      }\n    }\n    /**\n     * The modulation index when the sourceType === \"fm\"\n     * See [[FMOscillator]].\n     */\n\n  }, {\n    key: \"modulationIndex\",\n    get: function get() {\n      if (this._getOscType(this._oscillator, \"fm\")) {\n        return this._oscillator.modulationIndex;\n      } else {\n        return undefined;\n      }\n    }\n    /**\n     * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n     * See [[AMOscillator]] or [[FMOscillator]]\n     */\n\n  }, {\n    key: \"harmonicity\",\n    get: function get() {\n      if (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n        return this._oscillator.harmonicity;\n      } else {\n        return undefined;\n      }\n    }\n    /**\n     * The modulationFrequency Signal of the oscillator when sourceType === \"pwm\"\n     * see [[PWMOscillator]]\n     * @min 0.1\n     * @max 5\n     */\n\n  }, {\n    key: \"modulationFrequency\",\n    get: function get() {\n      if (this._getOscType(this._oscillator, \"pwm\")) {\n        return this._oscillator.modulationFrequency;\n      } else {\n        return undefined;\n      }\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(Oscillator.getDefaults(), FMOscillator.getDefaults(), AMOscillator.getDefaults(), FatOscillator.getDefaults(), PulseOscillator.getDefaults(), PWMOscillator.getDefaults());\n    }\n  }]);\n\n  return OmniOscillator;\n}(Source);","map":{"version":3,"sources":["../../../../Tone/source/oscillator/OmniOscillator.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __awaiter } from \"tslib\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isNumber, isString } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { AMOscillator } from \"./AMOscillator\";\nimport { FatOscillator } from \"./FatOscillator\";\nimport { FMOscillator } from \"./FMOscillator\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform } from \"./OscillatorInterface\";\nimport { PulseOscillator } from \"./PulseOscillator\";\nimport { PWMOscillator } from \"./PWMOscillator\";\nconst OmniOscillatorSourceMap = {\n    am: AMOscillator,\n    fat: FatOscillator,\n    fm: FMOscillator,\n    oscillator: Oscillator,\n    pulse: PulseOscillator,\n    pwm: PWMOscillator,\n};\n/**\n * OmniOscillator aggregates all of the oscillator types into one.\n * @example\n * return Tone.Offline(() => {\n * \tconst omniOsc = new Tone.OmniOscillator(\"C#4\", \"pwm\").toDestination().start();\n * }, 0.1, 1);\n * @category Source\n */\nexport class OmniOscillator extends Source {\n    constructor() {\n        super(optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n        this.name = \"OmniOscillator\";\n        const options = optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n        this.frequency = new Signal({\n            context: this.context,\n            units: \"frequency\",\n            value: options.frequency,\n        });\n        this.detune = new Signal({\n            context: this.context,\n            units: \"cents\",\n            value: options.detune,\n        });\n        readOnly(this, [\"frequency\", \"detune\"]);\n        // set the options\n        this.set(options);\n    }\n    static getDefaults() {\n        return Object.assign(Oscillator.getDefaults(), FMOscillator.getDefaults(), AMOscillator.getDefaults(), FatOscillator.getDefaults(), PulseOscillator.getDefaults(), PWMOscillator.getDefaults());\n    }\n    /**\n     * start the oscillator\n     */\n    _start(time) {\n        this._oscillator.start(time);\n    }\n    /**\n     * start the oscillator\n     */\n    _stop(time) {\n        this._oscillator.stop(time);\n    }\n    _restart(time) {\n        this._oscillator.restart(time);\n        return this;\n    }\n    /**\n     * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or\n     * prefix the basic types with \"fm\", \"am\", or \"fat\" to use the FMOscillator, AMOscillator or FatOscillator\n     * types. The oscillator could also be set to \"pwm\" or \"pulse\". All of the parameters of the\n     * oscillator's class are accessible when the oscillator is set to that type, but throws an error\n     * when it's not.\n     * @example\n     * const omniOsc = new Tone.OmniOscillator().toDestination().start();\n     * omniOsc.type = \"pwm\";\n     * // modulationFrequency is parameter which is available\n     * // only when the type is \"pwm\".\n     * omniOsc.modulationFrequency.value = 0.5;\n     */\n    get type() {\n        let prefix = \"\";\n        if ([\"am\", \"fm\", \"fat\"].some(p => this._sourceType === p)) {\n            prefix = this._sourceType;\n        }\n        return prefix + this._oscillator.type;\n    }\n    set type(type) {\n        if (type.substr(0, 2) === \"fm\") {\n            this._createNewOscillator(\"fm\");\n            this._oscillator = this._oscillator;\n            this._oscillator.type = type.substr(2);\n        }\n        else if (type.substr(0, 2) === \"am\") {\n            this._createNewOscillator(\"am\");\n            this._oscillator = this._oscillator;\n            this._oscillator.type = type.substr(2);\n        }\n        else if (type.substr(0, 3) === \"fat\") {\n            this._createNewOscillator(\"fat\");\n            this._oscillator = this._oscillator;\n            this._oscillator.type = type.substr(3);\n        }\n        else if (type === \"pwm\") {\n            this._createNewOscillator(\"pwm\");\n            this._oscillator = this._oscillator;\n        }\n        else if (type === \"pulse\") {\n            this._createNewOscillator(\"pulse\");\n        }\n        else {\n            this._createNewOscillator(\"oscillator\");\n            this._oscillator = this._oscillator;\n            this._oscillator.type = type;\n        }\n    }\n    /**\n     * The value is an empty array when the type is not \"custom\".\n     * This is not available on \"pwm\" and \"pulse\" oscillator types.\n     * See [[Oscillator.partials]]\n     */\n    get partials() {\n        return this._oscillator.partials;\n    }\n    set partials(partials) {\n        if (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n            this._oscillator.partials = partials;\n        }\n    }\n    get partialCount() {\n        return this._oscillator.partialCount;\n    }\n    set partialCount(partialCount) {\n        if (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n            this._oscillator.partialCount = partialCount;\n        }\n    }\n    set(props) {\n        // make sure the type is set first\n        if (Reflect.has(props, \"type\") && props.type) {\n            this.type = props.type;\n        }\n        // then set the rest\n        super.set(props);\n        return this;\n    }\n    /**\n     * connect the oscillator to the frequency and detune signals\n     */\n    _createNewOscillator(oscType) {\n        if (oscType !== this._sourceType) {\n            this._sourceType = oscType;\n            const OscConstructor = OmniOscillatorSourceMap[oscType];\n            // short delay to avoid clicks on the change\n            const now = this.now();\n            if (this._oscillator) {\n                const oldOsc = this._oscillator;\n                oldOsc.stop(now);\n                // dispose the old one\n                this.context.setTimeout(() => oldOsc.dispose(), this.blockTime);\n            }\n            this._oscillator = new OscConstructor({\n                context: this.context,\n            });\n            this.frequency.connect(this._oscillator.frequency);\n            this.detune.connect(this._oscillator.detune);\n            this._oscillator.connect(this.output);\n            this._oscillator.onstop = () => this.onstop(this);\n            if (this.state === \"started\") {\n                this._oscillator.start(now);\n            }\n        }\n    }\n    get phase() {\n        return this._oscillator.phase;\n    }\n    set phase(phase) {\n        this._oscillator.phase = phase;\n    }\n    /**\n     * The source type of the oscillator.\n     * @example\n     * const omniOsc = new Tone.OmniOscillator(440, \"fmsquare\");\n     * console.log(omniOsc.sourceType); // 'fm'\n     */\n    get sourceType() {\n        return this._sourceType;\n    }\n    set sourceType(sType) {\n        // the basetype defaults to sine\n        let baseType = \"sine\";\n        if (this._oscillator.type !== \"pwm\" && this._oscillator.type !== \"pulse\") {\n            baseType = this._oscillator.type;\n        }\n        // set the type\n        if (sType === \"fm\") {\n            this.type = \"fm\" + baseType;\n        }\n        else if (sType === \"am\") {\n            this.type = \"am\" + baseType;\n        }\n        else if (sType === \"fat\") {\n            this.type = \"fat\" + baseType;\n        }\n        else if (sType === \"oscillator\") {\n            this.type = baseType;\n        }\n        else if (sType === \"pulse\") {\n            this.type = \"pulse\";\n        }\n        else if (sType === \"pwm\") {\n            this.type = \"pwm\";\n        }\n    }\n    _getOscType(osc, sourceType) {\n        return osc instanceof OmniOscillatorSourceMap[sourceType];\n    }\n    /**\n     * The base type of the oscillator. See [[Oscillator.baseType]]\n     * @example\n     * const omniOsc = new Tone.OmniOscillator(440, \"fmsquare4\");\n     * console.log(omniOsc.sourceType, omniOsc.baseType, omniOsc.partialCount);\n     */\n    get baseType() {\n        return this._oscillator.baseType;\n    }\n    set baseType(baseType) {\n        if (!this._getOscType(this._oscillator, \"pulse\") &&\n            !this._getOscType(this._oscillator, \"pwm\") &&\n            baseType !== \"pulse\" && baseType !== \"pwm\") {\n            this._oscillator.baseType = baseType;\n        }\n    }\n    /**\n     * The width of the oscillator when sourceType === \"pulse\".\n     * See [[PWMOscillator.width]]\n     */\n    get width() {\n        if (this._getOscType(this._oscillator, \"pulse\")) {\n            return this._oscillator.width;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * The number of detuned oscillators when sourceType === \"fat\".\n     * See [[FatOscillator.count]]\n     */\n    get count() {\n        if (this._getOscType(this._oscillator, \"fat\")) {\n            return this._oscillator.count;\n        }\n        else {\n            return undefined;\n        }\n    }\n    set count(count) {\n        if (this._getOscType(this._oscillator, \"fat\") && isNumber(count)) {\n            this._oscillator.count = count;\n        }\n    }\n    /**\n     * The detune spread between the oscillators when sourceType === \"fat\".\n     * See [[FatOscillator.count]]\n     */\n    get spread() {\n        if (this._getOscType(this._oscillator, \"fat\")) {\n            return this._oscillator.spread;\n        }\n        else {\n            return undefined;\n        }\n    }\n    set spread(spread) {\n        if (this._getOscType(this._oscillator, \"fat\") && isNumber(spread)) {\n            this._oscillator.spread = spread;\n        }\n    }\n    /**\n     * The type of the modulator oscillator. Only if the oscillator is set to \"am\" or \"fm\" types.\n     * See [[AMOscillator]] or [[FMOscillator]]\n     */\n    get modulationType() {\n        if (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n            return this._oscillator.modulationType;\n        }\n        else {\n            return undefined;\n        }\n    }\n    set modulationType(mType) {\n        if ((this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) && isString(mType)) {\n            this._oscillator.modulationType = mType;\n        }\n    }\n    /**\n     * The modulation index when the sourceType === \"fm\"\n     * See [[FMOscillator]].\n     */\n    get modulationIndex() {\n        if (this._getOscType(this._oscillator, \"fm\")) {\n            return this._oscillator.modulationIndex;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n     * See [[AMOscillator]] or [[FMOscillator]]\n     */\n    get harmonicity() {\n        if (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n            return this._oscillator.harmonicity;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * The modulationFrequency Signal of the oscillator when sourceType === \"pwm\"\n     * see [[PWMOscillator]]\n     * @min 0.1\n     * @max 5\n     */\n    get modulationFrequency() {\n        if (this._getOscType(this._oscillator, \"pwm\")) {\n            return this._oscillator.modulationFrequency;\n        }\n        else {\n            return undefined;\n        }\n    }\n    asArray(length = 1024) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return generateWaveform(this, length);\n        });\n    }\n    dispose() {\n        super.dispose();\n        this.detune.dispose();\n        this.frequency.dispose();\n        this._oscillator.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=OmniOscillator.js.map"]},"metadata":{},"sourceType":"module"}