{"ast":null,"code":"import { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nexport var createStartRendering = function createStartRendering(audioBufferStore, cacheTestResult, getAudioNodeRenderer, getUnrenderedAudioWorkletNodes, renderNativeOfflineAudioContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) {\n  var trace = [];\n  return function (destination, nativeOfflineAudioContext) {\n    return getAudioNodeRenderer(destination).render(destination, nativeOfflineAudioContext, trace)\n    /*\n     * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to the\n     * destination.\n     */\n    .then(function () {\n      return Promise.all(Array.from(getUnrenderedAudioWorkletNodes(nativeOfflineAudioContext)).map(function (audioWorkletNode) {\n        return getAudioNodeRenderer(audioWorkletNode).render(audioWorkletNode, nativeOfflineAudioContext, trace);\n      }));\n    }).then(function () {\n      return renderNativeOfflineAudioContext(nativeOfflineAudioContext);\n    }).then(function (audioBuffer) {\n      // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n      // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n      if (typeof audioBuffer.copyFromChannel !== 'function') {\n        wrapAudioBufferCopyChannelMethods(audioBuffer);\n        wrapAudioBufferGetChannelDataMethod(audioBuffer); // Bug #157: Only Chrome & Opera do allow the bufferOffset to be out-of-bounds.\n      } else if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, function () {\n        return testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer);\n      })) {\n        wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n      }\n\n      audioBufferStore.add(audioBuffer);\n      return audioBuffer;\n    });\n  };\n};","map":{"version":3,"sources":["../../../src/factories/start-rendering.ts"],"names":[],"mappings":"AAAA,SAAS,mCAAT,QAAoD,sDAApD;AAGA,OAAO,IAAM,oBAAoB,GAA2B,SAA/C,oBAA+C,CACxD,gBADwD,EAExD,eAFwD,EAGxD,oBAHwD,EAIxD,8BAJwD,EAKxD,+BALwD,EAMxD,mDANwD,EAOxD,iCAPwD,EAQxD,4CARwD,EASxD;AACA,MAAM,KAAK,GAAG,EAAd;AAEA,SAAO,UAAC,WAAD,EAAc,yBAAd;AAAA,WACH,oBAAoB,CAAC,WAAD,CAApB,CACK,MADL,CACY,WADZ,EACyB,yBADzB,EACoD,KADpD;AAEI;;;;AAFJ,KAMK,IANL,CAMU;AAAA,aACF,OAAO,CAAC,GAAR,CACI,KAAK,CAAC,IAAN,CAAW,8BAA8B,CAAC,yBAAD,CAAzC,EAAsE,GAAtE,CAA0E,UAAC,gBAAD;AAAA,eACtE,oBAAoB,CAAC,gBAAD,CAApB,CAAuC,MAAvC,CAA8C,gBAA9C,EAAgE,yBAAhE,EAA2F,KAA3F,CADsE;AAAA,OAA1E,CADJ,CADE;AAAA,KANV,EAaK,IAbL,CAaU;AAAA,aAAM,+BAA+B,CAAC,yBAAD,CAArC;AAAA,KAbV,EAcK,IAdL,CAcU,UAAC,WAAD,EAAgB;AAClB;AACA;AACA,UAAI,OAAO,WAAW,CAAC,eAAnB,KAAuC,UAA3C,EAAuD;AACnD,QAAA,iCAAiC,CAAC,WAAD,CAAjC;AACA,QAAA,mCAAmC,CAAC,WAAD,CAAnC,CAFmD,CAGnD;AACH,OAJD,MAIO,IACH,CAAC,eAAe,CAAC,mDAAD,EAAsD;AAAA,eAClE,mDAAmD,CAAC,WAAD,CADe;AAAA,OAAtD,CADb,EAIL;AACE,QAAA,4CAA4C,CAAC,WAAD,CAA5C;AACH;;AAED,MAAA,gBAAgB,CAAC,GAAjB,CAAqB,WAArB;AAEA,aAAO,WAAP;AACH,KAhCL,CADG;AAAA,GAAP;AAkCH,CA9CM","sourceRoot":"","sourcesContent":["import { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nexport const createStartRendering = (audioBufferStore, cacheTestResult, getAudioNodeRenderer, getUnrenderedAudioWorkletNodes, renderNativeOfflineAudioContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) => {\n    const trace = [];\n    return (destination, nativeOfflineAudioContext) => getAudioNodeRenderer(destination)\n        .render(destination, nativeOfflineAudioContext, trace)\n        /*\n         * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to the\n         * destination.\n         */\n        .then(() => Promise.all(Array.from(getUnrenderedAudioWorkletNodes(nativeOfflineAudioContext)).map((audioWorkletNode) => getAudioNodeRenderer(audioWorkletNode).render(audioWorkletNode, nativeOfflineAudioContext, trace))))\n        .then(() => renderNativeOfflineAudioContext(nativeOfflineAudioContext))\n        .then((audioBuffer) => {\n        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n        // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n        if (typeof audioBuffer.copyFromChannel !== 'function') {\n            wrapAudioBufferCopyChannelMethods(audioBuffer);\n            wrapAudioBufferGetChannelDataMethod(audioBuffer);\n            // Bug #157: Only Chrome & Opera do allow the bufferOffset to be out-of-bounds.\n        }\n        else if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {\n            wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n        }\n        audioBufferStore.add(audioBuffer);\n        return audioBuffer;\n    });\n};\n//# sourceMappingURL=start-rendering.js.map"]},"metadata":{},"sourceType":"module"}