{"ast":null,"code":"import _classCallCheck from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { __decorate } from \"tslib\";\nimport { ToneAudioBuffers } from \"../core/context/ToneAudioBuffers\";\nimport { ftomf, intervalToFrequencyRatio } from \"../core/type/Conversions\";\nimport { FrequencyClass } from \"../core/type/Frequency\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { isArray, isNote, isNumber } from \"../core/util/TypeCheck\";\nimport { Instrument } from \"../instrument/Instrument\";\nimport { ToneBufferSource } from \"../source/buffer/ToneBufferSource\";\nimport { timeRange } from \"../core/util/Decorator\";\nimport { assert } from \"../core/util/Debug\";\n/**\n * Pass in an object which maps the note's pitch or midi value to the url,\n * then you can trigger the attack and release of that note like other instruments.\n * By automatically repitching the samples, it is possible to play pitches which\n * were not explicitly included which can save loading time.\n *\n * For sample or buffer playback where repitching is not necessary,\n * use [[Player]].\n * @example\n * const sampler = new Tone.Sampler({\n * \turls: {\n * \t\tA1: \"A1.mp3\",\n * \t\tA2: \"A2.mp3\",\n * \t},\n * \tbaseUrl: \"https://tonejs.github.io/audio/casio/\",\n * \tonload: () => {\n * \t\tsampler.triggerAttackRelease([\"C1\", \"E1\", \"G1\", \"B1\"], 0.5);\n * \t}\n * }).toDestination();\n * @category Instrument\n */\n\nexport var Sampler = /*#__PURE__*/function (_Instrument) {\n  _inherits(Sampler, _Instrument);\n\n  var _super = _createSuper(Sampler);\n\n  function Sampler() {\n    var _this;\n\n    _classCallCheck(this, Sampler);\n\n    _this = _super.call(this, optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\"));\n    _this.name = \"Sampler\";\n    /**\n     * The object of all currently playing BufferSources\n     */\n\n    _this._activeSources = new Map();\n    var options = optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\");\n    var urlMap = {};\n    Object.keys(options.urls).forEach(function (note) {\n      var noteNumber = parseInt(note, 10);\n      assert(isNote(note) || isNumber(noteNumber) && isFinite(noteNumber), \"url key is neither a note or midi pitch: \".concat(note));\n\n      if (isNote(note)) {\n        // convert the note name to MIDI\n        var mid = new FrequencyClass(_this.context, note).toMidi();\n        urlMap[mid] = options.urls[note];\n      } else if (isNumber(noteNumber) && isFinite(noteNumber)) {\n        // otherwise if it's numbers assume it's midi\n        urlMap[noteNumber] = options.urls[noteNumber];\n      }\n    });\n    _this._buffers = new ToneAudioBuffers({\n      urls: urlMap,\n      onload: options.onload,\n      baseUrl: options.baseUrl,\n      onerror: options.onerror\n    });\n    _this.attack = options.attack;\n    _this.release = options.release;\n    _this.curve = options.curve; // invoke the callback if it's already loaded\n\n    if (_this._buffers.loaded) {\n      // invoke onload deferred\n      Promise.resolve().then(options.onload);\n    }\n\n    return _this;\n  }\n\n  _createClass(Sampler, [{\n    key: \"_findClosest\",\n\n    /**\n     * Returns the difference in steps between the given midi note at the closets sample.\n     */\n    value: function _findClosest(midi) {\n      // searches within 8 octaves of the given midi note\n      var MAX_INTERVAL = 96;\n      var interval = 0;\n\n      while (interval < MAX_INTERVAL) {\n        // check above and below\n        if (this._buffers.has(midi + interval)) {\n          return -interval;\n        } else if (this._buffers.has(midi - interval)) {\n          return interval;\n        }\n\n        interval++;\n      }\n\n      throw new Error(\"No available buffers for note: \".concat(midi));\n    }\n    /**\n     * @param  notes\tThe note to play, or an array of notes.\n     * @param  time     When to play the note\n     * @param  velocity The velocity to play the sample back.\n     */\n\n  }, {\n    key: \"triggerAttack\",\n    value: function triggerAttack(notes, time) {\n      var _this2 = this;\n\n      var velocity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      this.log(\"triggerAttack\", notes, time, velocity);\n\n      if (!Array.isArray(notes)) {\n        notes = [notes];\n      }\n\n      notes.forEach(function (note) {\n        var midiFloat = ftomf(new FrequencyClass(_this2.context, note).toFrequency());\n        var midi = Math.round(midiFloat);\n        var remainder = midiFloat - midi; // find the closest note pitch\n\n        var difference = _this2._findClosest(midi);\n\n        var closestNote = midi - difference;\n\n        var buffer = _this2._buffers.get(closestNote);\n\n        var playbackRate = intervalToFrequencyRatio(difference + remainder); // play that note\n\n        var source = new ToneBufferSource({\n          url: buffer,\n          context: _this2.context,\n          curve: _this2.curve,\n          fadeIn: _this2.attack,\n          fadeOut: _this2.release,\n          playbackRate: playbackRate\n        }).connect(_this2.output);\n        source.start(time, 0, buffer.duration / playbackRate, velocity); // add it to the active sources\n\n        if (!isArray(_this2._activeSources.get(midi))) {\n          _this2._activeSources.set(midi, []);\n        }\n\n        _this2._activeSources.get(midi).push(source); // remove it when it's done\n\n\n        source.onended = function () {\n          if (_this2._activeSources && _this2._activeSources.has(midi)) {\n            var sources = _this2._activeSources.get(midi);\n\n            var index = sources.indexOf(source);\n\n            if (index !== -1) {\n              sources.splice(index, 1);\n            }\n          }\n        };\n      });\n      return this;\n    }\n    /**\n     * @param  notes\tThe note to release, or an array of notes.\n     * @param  time     \tWhen to release the note.\n     */\n\n  }, {\n    key: \"triggerRelease\",\n    value: function triggerRelease(notes, time) {\n      var _this3 = this;\n\n      this.log(\"triggerRelease\", notes, time);\n\n      if (!Array.isArray(notes)) {\n        notes = [notes];\n      }\n\n      notes.forEach(function (note) {\n        var midi = new FrequencyClass(_this3.context, note).toMidi(); // find the note\n\n        if (_this3._activeSources.has(midi) && _this3._activeSources.get(midi).length) {\n          var sources = _this3._activeSources.get(midi);\n\n          time = _this3.toSeconds(time);\n          sources.forEach(function (source) {\n            source.stop(time);\n          });\n\n          _this3._activeSources.set(midi, []);\n        }\n      });\n      return this;\n    }\n    /**\n     * Release all currently active notes.\n     * @param  time     \tWhen to release the notes.\n     */\n\n  }, {\n    key: \"releaseAll\",\n    value: function releaseAll(time) {\n      var computedTime = this.toSeconds(time);\n\n      this._activeSources.forEach(function (sources) {\n        while (sources.length) {\n          var source = sources.shift();\n          source.stop(computedTime);\n        }\n      });\n\n      return this;\n    }\n  }, {\n    key: \"sync\",\n    value: function sync() {\n      this._syncMethod(\"triggerAttack\", 1);\n\n      this._syncMethod(\"triggerRelease\", 1);\n\n      return this;\n    }\n    /**\n     * Invoke the attack phase, then after the duration, invoke the release.\n     * @param  notes\tThe note to play and release, or an array of notes.\n     * @param  duration The time the note should be held\n     * @param  time     When to start the attack\n     * @param  velocity The velocity of the attack\n     */\n\n  }, {\n    key: \"triggerAttackRelease\",\n    value: function triggerAttackRelease(notes, duration, time) {\n      var _this4 = this;\n\n      var velocity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n      var computedTime = this.toSeconds(time);\n      this.triggerAttack(notes, computedTime, velocity);\n\n      if (isArray(duration)) {\n        assert(isArray(notes), \"notes must be an array when duration is array\");\n        notes.forEach(function (note, index) {\n          var d = duration[Math.min(index, duration.length - 1)];\n\n          _this4.triggerRelease(note, computedTime + _this4.toSeconds(d));\n        });\n      } else {\n        this.triggerRelease(notes, computedTime + this.toSeconds(duration));\n      }\n\n      return this;\n    }\n    /**\n     * Add a note to the sampler.\n     * @param  note      The buffer's pitch.\n     * @param  url  Either the url of the buffer, or a buffer which will be added with the given name.\n     * @param  callback  The callback to invoke when the url is loaded.\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(note, url, callback) {\n      assert(isNote(note) || isFinite(note), \"note must be a pitch or midi: \".concat(note));\n\n      if (isNote(note)) {\n        // convert the note name to MIDI\n        var mid = new FrequencyClass(this.context, note).toMidi();\n\n        this._buffers.add(mid, url, callback);\n      } else {\n        // otherwise if it's numbers assume it's midi\n        this._buffers.add(note, url, callback);\n      }\n\n      return this;\n    }\n    /**\n     * If the buffers are loaded or not\n     */\n\n  }, {\n    key: \"dispose\",\n\n    /**\n     * Clean up\n     */\n    value: function dispose() {\n      _get(_getPrototypeOf(Sampler.prototype), \"dispose\", this).call(this);\n\n      this._buffers.dispose();\n\n      this._activeSources.forEach(function (sources) {\n        sources.forEach(function (source) {\n          return source.dispose();\n        });\n      });\n\n      this._activeSources.clear();\n\n      return this;\n    }\n  }, {\n    key: \"loaded\",\n    get: function get() {\n      return this._buffers.loaded;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(Instrument.getDefaults(), {\n        attack: 0,\n        baseUrl: \"\",\n        curve: \"exponential\",\n        onload: noOp,\n        onerror: noOp,\n        release: 0.1,\n        urls: {}\n      });\n    }\n  }]);\n\n  return Sampler;\n}(Instrument);\n\n__decorate([timeRange(0)], Sampler.prototype, \"attack\", void 0);\n\n__decorate([timeRange(0)], Sampler.prototype, \"release\", void 0);","map":{"version":3,"sources":["../../../Tone/instrument/Sampler.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __decorate } from \"tslib\";\nimport { ToneAudioBuffers } from \"../core/context/ToneAudioBuffers\";\nimport { ftomf, intervalToFrequencyRatio } from \"../core/type/Conversions\";\nimport { FrequencyClass } from \"../core/type/Frequency\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { isArray, isNote, isNumber } from \"../core/util/TypeCheck\";\nimport { Instrument } from \"../instrument/Instrument\";\nimport { ToneBufferSource } from \"../source/buffer/ToneBufferSource\";\nimport { timeRange } from \"../core/util/Decorator\";\nimport { assert } from \"../core/util/Debug\";\n/**\n * Pass in an object which maps the note's pitch or midi value to the url,\n * then you can trigger the attack and release of that note like other instruments.\n * By automatically repitching the samples, it is possible to play pitches which\n * were not explicitly included which can save loading time.\n *\n * For sample or buffer playback where repitching is not necessary,\n * use [[Player]].\n * @example\n * const sampler = new Tone.Sampler({\n * \turls: {\n * \t\tA1: \"A1.mp3\",\n * \t\tA2: \"A2.mp3\",\n * \t},\n * \tbaseUrl: \"https://tonejs.github.io/audio/casio/\",\n * \tonload: () => {\n * \t\tsampler.triggerAttackRelease([\"C1\", \"E1\", \"G1\", \"B1\"], 0.5);\n * \t}\n * }).toDestination();\n * @category Instrument\n */\nexport class Sampler extends Instrument {\n    constructor() {\n        super(optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\"));\n        this.name = \"Sampler\";\n        /**\n         * The object of all currently playing BufferSources\n         */\n        this._activeSources = new Map();\n        const options = optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\");\n        const urlMap = {};\n        Object.keys(options.urls).forEach((note) => {\n            const noteNumber = parseInt(note, 10);\n            assert(isNote(note)\n                || (isNumber(noteNumber) && isFinite(noteNumber)), `url key is neither a note or midi pitch: ${note}`);\n            if (isNote(note)) {\n                // convert the note name to MIDI\n                const mid = new FrequencyClass(this.context, note).toMidi();\n                urlMap[mid] = options.urls[note];\n            }\n            else if (isNumber(noteNumber) && isFinite(noteNumber)) {\n                // otherwise if it's numbers assume it's midi\n                urlMap[noteNumber] = options.urls[noteNumber];\n            }\n        });\n        this._buffers = new ToneAudioBuffers({\n            urls: urlMap,\n            onload: options.onload,\n            baseUrl: options.baseUrl,\n            onerror: options.onerror,\n        });\n        this.attack = options.attack;\n        this.release = options.release;\n        this.curve = options.curve;\n        // invoke the callback if it's already loaded\n        if (this._buffers.loaded) {\n            // invoke onload deferred\n            Promise.resolve().then(options.onload);\n        }\n    }\n    static getDefaults() {\n        return Object.assign(Instrument.getDefaults(), {\n            attack: 0,\n            baseUrl: \"\",\n            curve: \"exponential\",\n            onload: noOp,\n            onerror: noOp,\n            release: 0.1,\n            urls: {},\n        });\n    }\n    /**\n     * Returns the difference in steps between the given midi note at the closets sample.\n     */\n    _findClosest(midi) {\n        // searches within 8 octaves of the given midi note\n        const MAX_INTERVAL = 96;\n        let interval = 0;\n        while (interval < MAX_INTERVAL) {\n            // check above and below\n            if (this._buffers.has(midi + interval)) {\n                return -interval;\n            }\n            else if (this._buffers.has(midi - interval)) {\n                return interval;\n            }\n            interval++;\n        }\n        throw new Error(`No available buffers for note: ${midi}`);\n    }\n    /**\n     * @param  notes\tThe note to play, or an array of notes.\n     * @param  time     When to play the note\n     * @param  velocity The velocity to play the sample back.\n     */\n    triggerAttack(notes, time, velocity = 1) {\n        this.log(\"triggerAttack\", notes, time, velocity);\n        if (!Array.isArray(notes)) {\n            notes = [notes];\n        }\n        notes.forEach(note => {\n            const midiFloat = ftomf(new FrequencyClass(this.context, note).toFrequency());\n            const midi = Math.round(midiFloat);\n            const remainder = midiFloat - midi;\n            // find the closest note pitch\n            const difference = this._findClosest(midi);\n            const closestNote = midi - difference;\n            const buffer = this._buffers.get(closestNote);\n            const playbackRate = intervalToFrequencyRatio(difference + remainder);\n            // play that note\n            const source = new ToneBufferSource({\n                url: buffer,\n                context: this.context,\n                curve: this.curve,\n                fadeIn: this.attack,\n                fadeOut: this.release,\n                playbackRate,\n            }).connect(this.output);\n            source.start(time, 0, buffer.duration / playbackRate, velocity);\n            // add it to the active sources\n            if (!isArray(this._activeSources.get(midi))) {\n                this._activeSources.set(midi, []);\n            }\n            this._activeSources.get(midi).push(source);\n            // remove it when it's done\n            source.onended = () => {\n                if (this._activeSources && this._activeSources.has(midi)) {\n                    const sources = this._activeSources.get(midi);\n                    const index = sources.indexOf(source);\n                    if (index !== -1) {\n                        sources.splice(index, 1);\n                    }\n                }\n            };\n        });\n        return this;\n    }\n    /**\n     * @param  notes\tThe note to release, or an array of notes.\n     * @param  time     \tWhen to release the note.\n     */\n    triggerRelease(notes, time) {\n        this.log(\"triggerRelease\", notes, time);\n        if (!Array.isArray(notes)) {\n            notes = [notes];\n        }\n        notes.forEach(note => {\n            const midi = new FrequencyClass(this.context, note).toMidi();\n            // find the note\n            if (this._activeSources.has(midi) && this._activeSources.get(midi).length) {\n                const sources = this._activeSources.get(midi);\n                time = this.toSeconds(time);\n                sources.forEach(source => {\n                    source.stop(time);\n                });\n                this._activeSources.set(midi, []);\n            }\n        });\n        return this;\n    }\n    /**\n     * Release all currently active notes.\n     * @param  time     \tWhen to release the notes.\n     */\n    releaseAll(time) {\n        const computedTime = this.toSeconds(time);\n        this._activeSources.forEach(sources => {\n            while (sources.length) {\n                const source = sources.shift();\n                source.stop(computedTime);\n            }\n        });\n        return this;\n    }\n    sync() {\n        this._syncMethod(\"triggerAttack\", 1);\n        this._syncMethod(\"triggerRelease\", 1);\n        return this;\n    }\n    /**\n     * Invoke the attack phase, then after the duration, invoke the release.\n     * @param  notes\tThe note to play and release, or an array of notes.\n     * @param  duration The time the note should be held\n     * @param  time     When to start the attack\n     * @param  velocity The velocity of the attack\n     */\n    triggerAttackRelease(notes, duration, time, velocity = 1) {\n        const computedTime = this.toSeconds(time);\n        this.triggerAttack(notes, computedTime, velocity);\n        if (isArray(duration)) {\n            assert(isArray(notes), \"notes must be an array when duration is array\");\n            notes.forEach((note, index) => {\n                const d = duration[Math.min(index, duration.length - 1)];\n                this.triggerRelease(note, computedTime + this.toSeconds(d));\n            });\n        }\n        else {\n            this.triggerRelease(notes, computedTime + this.toSeconds(duration));\n        }\n        return this;\n    }\n    /**\n     * Add a note to the sampler.\n     * @param  note      The buffer's pitch.\n     * @param  url  Either the url of the buffer, or a buffer which will be added with the given name.\n     * @param  callback  The callback to invoke when the url is loaded.\n     */\n    add(note, url, callback) {\n        assert(isNote(note) || isFinite(note), `note must be a pitch or midi: ${note}`);\n        if (isNote(note)) {\n            // convert the note name to MIDI\n            const mid = new FrequencyClass(this.context, note).toMidi();\n            this._buffers.add(mid, url, callback);\n        }\n        else {\n            // otherwise if it's numbers assume it's midi\n            this._buffers.add(note, url, callback);\n        }\n        return this;\n    }\n    /**\n     * If the buffers are loaded or not\n     */\n    get loaded() {\n        return this._buffers.loaded;\n    }\n    /**\n     * Clean up\n     */\n    dispose() {\n        super.dispose();\n        this._buffers.dispose();\n        this._activeSources.forEach(sources => {\n            sources.forEach(source => source.dispose());\n        });\n        this._activeSources.clear();\n        return this;\n    }\n}\n__decorate([\n    timeRange(0)\n], Sampler.prototype, \"attack\", void 0);\n__decorate([\n    timeRange(0)\n], Sampler.prototype, \"release\", void 0);\n//# sourceMappingURL=Sampler.js.map"]},"metadata":{},"sourceType":"module"}