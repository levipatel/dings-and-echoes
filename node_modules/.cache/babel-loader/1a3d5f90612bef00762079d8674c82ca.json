{"ast":null,"code":"import _objectSpread from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _classCallCheck from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { testPromiseSupport } from '../helpers/test-promise-support';\nvar DEFAULT_OPTIONS = {\n  numberOfChannels: 1\n};\nexport var createMinimalOfflineAudioContextConstructor = function createMinimalOfflineAudioContextConstructor(cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, minimalBaseAudioContextConstructor, _startRendering) {\n  return /*#__PURE__*/function (_minimalBaseAudioCont) {\n    _inherits(MinimalOfflineAudioContext, _minimalBaseAudioCont);\n\n    var _super = _createSuper(MinimalOfflineAudioContext);\n\n    function MinimalOfflineAudioContext(options) {\n      var _this;\n\n      _classCallCheck(this, MinimalOfflineAudioContext);\n\n      var _DEFAULT_OPTIONS$opti = _objectSpread(_objectSpread({}, DEFAULT_OPTIONS), options),\n          length = _DEFAULT_OPTIONS$opti.length,\n          numberOfChannels = _DEFAULT_OPTIONS$opti.numberOfChannels,\n          sampleRate = _DEFAULT_OPTIONS$opti.sampleRate;\n\n      var nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate); // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n\n      if (!cacheTestResult(testPromiseSupport, function () {\n        return testPromiseSupport(nativeOfflineAudioContext);\n      })) {\n        nativeOfflineAudioContext.addEventListener('statechange', function () {\n          var i = 0;\n\n          var delayStateChangeEvent = function delayStateChangeEvent(event) {\n            if (_this._state === 'running') {\n              if (i > 0) {\n                nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                event.stopImmediatePropagation();\n\n                _this._waitForThePromiseToSettle(event);\n              } else {\n                i += 1;\n              }\n            }\n          };\n\n          return delayStateChangeEvent;\n        }());\n      }\n\n      _this = _super.call(this, nativeOfflineAudioContext, numberOfChannels);\n      _this._length = length;\n      _this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n      _this._state = null;\n      return _this;\n    }\n\n    _createClass(MinimalOfflineAudioContext, [{\n      key: \"startRendering\",\n      value: function startRendering() {\n        var _this2 = this;\n\n        /*\n         * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n         * the state of the nativeOfflineAudioContext might no transition to running immediately.\n         */\n        if (this._state === 'running') {\n          return Promise.reject(createInvalidStateError());\n        }\n\n        this._state = 'running';\n        return _startRendering(this.destination, this._nativeOfflineAudioContext).then(function (audioBuffer) {\n          _this2._state = null;\n          /*\n           * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n           * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n           */\n\n          return audioBuffer;\n        }) // @todo This could be written more elegantly when Promise.finally() becomes avalaible.\n        .catch(function (err) {\n          _this2._state = null;\n          /*\n           * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n           * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n           */\n\n          throw err;\n        });\n      }\n    }, {\n      key: \"_waitForThePromiseToSettle\",\n      value: function _waitForThePromiseToSettle(event) {\n        var _this3 = this;\n\n        if (this._state === null) {\n          this._nativeOfflineAudioContext.dispatchEvent(event);\n        } else {\n          setTimeout(function () {\n            return _this3._waitForThePromiseToSettle(event);\n          });\n        }\n      }\n    }, {\n      key: \"length\",\n      get: function get() {\n        // Bug #17: Safari does not yet expose the length.\n        if (this._nativeOfflineAudioContext.length === undefined) {\n          return this._length;\n        }\n\n        return this._nativeOfflineAudioContext.length;\n      }\n    }, {\n      key: \"state\",\n      get: function get() {\n        return this._state === null ? this._nativeOfflineAudioContext.state : this._state;\n      }\n    }]);\n\n    return MinimalOfflineAudioContext;\n  }(minimalBaseAudioContextConstructor);\n};","map":{"version":3,"sources":["../../../src/factories/minimal-offline-audio-context-constructor.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { testPromiseSupport } from '../helpers/test-promise-support';\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n};\nexport const createMinimalOfflineAudioContextConstructor = (cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, minimalBaseAudioContextConstructor, startRendering) => {\n    return class MinimalOfflineAudioContext extends minimalBaseAudioContextConstructor {\n        constructor(options) {\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n            const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate);\n            // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n            if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n                nativeOfflineAudioContext.addEventListener('statechange', (() => {\n                    let i = 0;\n                    const delayStateChangeEvent = (event) => {\n                        if (this._state === 'running') {\n                            if (i > 0) {\n                                nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                                event.stopImmediatePropagation();\n                                this._waitForThePromiseToSettle(event);\n                            }\n                            else {\n                                i += 1;\n                            }\n                        }\n                    };\n                    return delayStateChangeEvent;\n                })());\n            }\n            super(nativeOfflineAudioContext, numberOfChannels);\n            this._length = length;\n            this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n            this._state = null;\n        }\n        get length() {\n            // Bug #17: Safari does not yet expose the length.\n            if (this._nativeOfflineAudioContext.length === undefined) {\n                return this._length;\n            }\n            return this._nativeOfflineAudioContext.length;\n        }\n        get state() {\n            return this._state === null ? this._nativeOfflineAudioContext.state : this._state;\n        }\n        startRendering() {\n            /*\n             * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n             * the state of the nativeOfflineAudioContext might no transition to running immediately.\n             */\n            if (this._state === 'running') {\n                return Promise.reject(createInvalidStateError());\n            }\n            this._state = 'running';\n            return (startRendering(this.destination, this._nativeOfflineAudioContext)\n                .then((audioBuffer) => {\n                this._state = null;\n                /*\n                 * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n                 * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n                 */\n                return audioBuffer;\n            })\n                // @todo This could be written more elegantly when Promise.finally() becomes avalaible.\n                .catch((err) => {\n                this._state = null;\n                /*\n                 * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n                 * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n                 */\n                throw err;\n            }));\n        }\n        _waitForThePromiseToSettle(event) {\n            if (this._state === null) {\n                this._nativeOfflineAudioContext.dispatchEvent(event);\n            }\n            else {\n                setTimeout(() => this._waitForThePromiseToSettle(event));\n            }\n        }\n    };\n};\n//# sourceMappingURL=minimal-offline-audio-context-constructor.js.map"]},"metadata":{},"sourceType":"module"}