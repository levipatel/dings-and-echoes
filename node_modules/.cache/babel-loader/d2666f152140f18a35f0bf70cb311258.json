{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _regeneratorRuntime from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _classCallCheck from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { __awaiter } from \"tslib\";\nimport { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { isAudioBuffer } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { noOp } from \"../util/Interface\";\nimport { isArray, isNumber, isString } from \"../util/TypeCheck\";\nimport { assert } from \"../util/Debug\";\n/**\n * AudioBuffer loading and storage. ToneAudioBuffer is used internally by all\n * classes that make requests for audio files such as Tone.Player,\n * Tone.Sampler and Tone.Convolver.\n * Aside from load callbacks from individual buffers, ToneAudioBuffer\n * provides events which keep track of the loading progress\n * of _all_ of the buffers. These are ToneAudioBuffer.on(\"load\" / \"progress\" / \"error\")\n * @example\n * const buffer = new Tone.ToneAudioBuffer(\"https://tonejs.github.io/audio/casio/A1.mp3\", () => {\n * \tconsole.log(\"loaded\");\n * });\n * @category Core\n */\n\nexport var ToneAudioBuffer = /*#__PURE__*/function (_Tone) {\n  _inherits(ToneAudioBuffer, _Tone);\n\n  var _super = _createSuper(ToneAudioBuffer);\n\n  function ToneAudioBuffer() {\n    var _this;\n\n    _classCallCheck(this, ToneAudioBuffer);\n\n    _this = _super.call(this);\n    _this.name = \"ToneAudioBuffer\";\n    /**\n     * Callback when the buffer is loaded.\n     */\n\n    _this.onload = noOp;\n    var options = optionsFromArguments(ToneAudioBuffer.getDefaults(), arguments, [\"url\", \"onload\", \"onerror\"]);\n    _this.reverse = options.reverse;\n    _this.onload = options.onload;\n\n    if (options.url && isAudioBuffer(options.url) || options.url instanceof ToneAudioBuffer) {\n      _this.set(options.url);\n    } else if (isString(options.url)) {\n      // initiate the download\n      _this.load(options.url).catch(options.onerror);\n    }\n\n    return _this;\n  }\n\n  _createClass(ToneAudioBuffer, [{\n    key: \"set\",\n\n    /**\n     * Pass in an AudioBuffer or ToneAudioBuffer to set the value of this buffer.\n     */\n    value: function set(buffer) {\n      var _this2 = this;\n\n      if (buffer instanceof ToneAudioBuffer) {\n        // if it's loaded, set it\n        if (buffer.loaded) {\n          this._buffer = buffer.get();\n        } else {\n          // otherwise when it's loaded, invoke it's callback\n          buffer.onload = function () {\n            _this2.set(buffer);\n\n            _this2.onload(_this2);\n          };\n        }\n      } else {\n        this._buffer = buffer;\n      } // reverse it initially\n\n\n      if (this._reversed) {\n        this._reverse();\n      }\n\n      return this;\n    }\n    /**\n     * The audio buffer stored in the object.\n     */\n\n  }, {\n    key: \"get\",\n    value: function get() {\n      return this._buffer;\n    }\n    /**\n     * Makes an fetch request for the selected url then decodes the file as an audio buffer.\n     * Invokes the callback once the audio buffer loads.\n     * @param url The url of the buffer to load. filetype support depends on the browser.\n     * @returns A Promise which resolves with this ToneAudioBuffer\n     */\n\n  }, {\n    key: \"load\",\n    value: function load(url) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this3 = this;\n\n        var doneLoading, index;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                doneLoading = ToneAudioBuffer.load(url).then(function (audioBuffer) {\n                  _this3.set(audioBuffer); // invoke the onload method\n\n\n                  _this3.onload(_this3);\n                });\n                ToneAudioBuffer.downloads.push(doneLoading);\n                _context.prev = 2;\n                _context.next = 5;\n                return doneLoading;\n\n              case 5:\n                _context.prev = 5;\n                // remove the downloaded file\n                index = ToneAudioBuffer.downloads.indexOf(doneLoading);\n                ToneAudioBuffer.downloads.splice(index, 1);\n                return _context.finish(5);\n\n              case 9:\n                return _context.abrupt(\"return\", this);\n\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[2,, 5, 9]]);\n      }));\n    }\n    /**\n     * clean up\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(ToneAudioBuffer.prototype), \"dispose\", this).call(this);\n\n      this._buffer = undefined;\n      return this;\n    }\n    /**\n     * Set the audio buffer from the array.\n     * To create a multichannel AudioBuffer, pass in a multidimensional array.\n     * @param array The array to fill the audio buffer\n     */\n\n  }, {\n    key: \"fromArray\",\n    value: function fromArray(array) {\n      var isMultidimensional = isArray(array) && array[0].length > 0;\n      var channels = isMultidimensional ? array.length : 1;\n      var len = isMultidimensional ? array[0].length : array.length;\n      var context = getContext();\n      var buffer = context.createBuffer(channels, len, context.sampleRate);\n      var multiChannelArray = !isMultidimensional && channels === 1 ? [array] : array;\n\n      for (var c = 0; c < channels; c++) {\n        buffer.copyToChannel(multiChannelArray[c], c);\n      }\n\n      this._buffer = buffer;\n      return this;\n    }\n    /**\n     * Sums multiple channels into 1 channel\n     * @param chanNum Optionally only copy a single channel from the array.\n     */\n\n  }, {\n    key: \"toMono\",\n    value: function toMono(chanNum) {\n      if (isNumber(chanNum)) {\n        this.fromArray(this.toArray(chanNum));\n      } else {\n        var outputArray = new Float32Array(this.length);\n        var numChannels = this.numberOfChannels;\n\n        for (var channel = 0; channel < numChannels; channel++) {\n          var channelArray = this.toArray(channel);\n\n          for (var i = 0; i < channelArray.length; i++) {\n            outputArray[i] += channelArray[i];\n          }\n        } // divide by the number of channels\n\n\n        outputArray = outputArray.map(function (sample) {\n          return sample / numChannels;\n        });\n        this.fromArray(outputArray);\n      }\n\n      return this;\n    }\n    /**\n     * Get the buffer as an array. Single channel buffers will return a 1-dimensional\n     * Float32Array, and multichannel buffers will return multidimensional arrays.\n     * @param channel Optionally only copy a single channel from the array.\n     */\n\n  }, {\n    key: \"toArray\",\n    value: function toArray(channel) {\n      if (isNumber(channel)) {\n        return this.getChannelData(channel);\n      } else if (this.numberOfChannels === 1) {\n        return this.toArray(0);\n      } else {\n        var ret = [];\n\n        for (var c = 0; c < this.numberOfChannels; c++) {\n          ret[c] = this.getChannelData(c);\n        }\n\n        return ret;\n      }\n    }\n    /**\n     * Returns the Float32Array representing the PCM audio data for the specific channel.\n     * @param  channel  The channel number to return\n     * @return The audio as a TypedArray\n     */\n\n  }, {\n    key: \"getChannelData\",\n    value: function getChannelData(channel) {\n      if (this._buffer) {\n        return this._buffer.getChannelData(channel);\n      } else {\n        return new Float32Array(0);\n      }\n    }\n    /**\n     * Cut a subsection of the array and return a buffer of the\n     * subsection. Does not modify the original buffer\n     * @param start The time to start the slice\n     * @param end The end time to slice. If none is given will default to the end of the buffer\n     */\n\n  }, {\n    key: \"slice\",\n    value: function slice(start) {\n      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.duration;\n      var startSamples = Math.floor(start * this.sampleRate);\n      var endSamples = Math.floor(end * this.sampleRate);\n      assert(startSamples < endSamples, \"The start time must be less than the end time\");\n      var length = endSamples - startSamples;\n      var retBuffer = getContext().createBuffer(this.numberOfChannels, length, this.sampleRate);\n\n      for (var channel = 0; channel < this.numberOfChannels; channel++) {\n        retBuffer.copyToChannel(this.getChannelData(channel).subarray(startSamples, endSamples), channel);\n      }\n\n      return new ToneAudioBuffer(retBuffer);\n    }\n    /**\n     * Reverse the buffer.\n     */\n\n  }, {\n    key: \"_reverse\",\n    value: function _reverse() {\n      if (this.loaded) {\n        for (var i = 0; i < this.numberOfChannels; i++) {\n          this.getChannelData(i).reverse();\n        }\n      }\n\n      return this;\n    }\n    /**\n     * If the buffer is loaded or not\n     */\n\n  }, {\n    key: \"sampleRate\",\n\n    /**\n     * The sample rate of the AudioBuffer\n     */\n    get: function get() {\n      if (this._buffer) {\n        return this._buffer.sampleRate;\n      } else {\n        return getContext().sampleRate;\n      }\n    }\n  }, {\n    key: \"loaded\",\n    get: function get() {\n      return this.length > 0;\n    }\n    /**\n     * The duration of the buffer in seconds.\n     */\n\n  }, {\n    key: \"duration\",\n    get: function get() {\n      if (this._buffer) {\n        return this._buffer.duration;\n      } else {\n        return 0;\n      }\n    }\n    /**\n     * The length of the buffer in samples\n     */\n\n  }, {\n    key: \"length\",\n    get: function get() {\n      if (this._buffer) {\n        return this._buffer.length;\n      } else {\n        return 0;\n      }\n    }\n    /**\n     * The number of discrete audio channels. Returns 0 if no buffer is loaded.\n     */\n\n  }, {\n    key: \"numberOfChannels\",\n    get: function get() {\n      if (this._buffer) {\n        return this._buffer.numberOfChannels;\n      } else {\n        return 0;\n      }\n    }\n    /**\n     * Reverse the buffer.\n     */\n\n  }, {\n    key: \"reverse\",\n    get: function get() {\n      return this._reversed;\n    },\n    set: function set(rev) {\n      if (this._reversed !== rev) {\n        this._reversed = rev;\n\n        this._reverse();\n      }\n    }\n    /**\n     * Create a ToneAudioBuffer from the array. To create a multichannel AudioBuffer,\n     * pass in a multidimensional array.\n     * @param array The array to fill the audio buffer\n     * @return A ToneAudioBuffer created from the array\n     */\n\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return {\n        onerror: noOp,\n        onload: noOp,\n        reverse: false\n      };\n    }\n  }, {\n    key: \"fromArray\",\n    value: function fromArray(array) {\n      return new ToneAudioBuffer().fromArray(array);\n    }\n    /**\n     * Creates a ToneAudioBuffer from a URL, returns a promise which resolves to a ToneAudioBuffer\n     * @param  url The url to load.\n     * @return A promise which resolves to a ToneAudioBuffer\n     */\n\n  }, {\n    key: \"fromUrl\",\n    value: function fromUrl(url) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var buffer;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                buffer = new ToneAudioBuffer();\n                _context2.next = 3;\n                return buffer.load(url);\n\n              case 3:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n    }\n    /**\n     * Loads a url using fetch and returns the AudioBuffer.\n     */\n\n  }, {\n    key: \"load\",\n    value: function load(url) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var matches, extensions, extension, _iterator, _step, ext, baseUrl, response, arrayBuffer, audioBuffer;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                // test if the url contains multiple extensions\n                matches = url.match(/\\[(.+\\|?)+\\]$/);\n\n                if (!matches) {\n                  _context3.next = 23;\n                  break;\n                }\n\n                extensions = matches[1].split(\"|\");\n                extension = extensions[0];\n                _iterator = _createForOfIteratorHelper(extensions);\n                _context3.prev = 5;\n\n                _iterator.s();\n\n              case 7:\n                if ((_step = _iterator.n()).done) {\n                  _context3.next = 14;\n                  break;\n                }\n\n                ext = _step.value;\n\n                if (!ToneAudioBuffer.supportsType(ext)) {\n                  _context3.next = 12;\n                  break;\n                }\n\n                extension = ext;\n                return _context3.abrupt(\"break\", 14);\n\n              case 12:\n                _context3.next = 7;\n                break;\n\n              case 14:\n                _context3.next = 19;\n                break;\n\n              case 16:\n                _context3.prev = 16;\n                _context3.t0 = _context3[\"catch\"](5);\n\n                _iterator.e(_context3.t0);\n\n              case 19:\n                _context3.prev = 19;\n\n                _iterator.f();\n\n                return _context3.finish(19);\n\n              case 22:\n                url = url.replace(matches[0], extension);\n\n              case 23:\n                // make sure there is a slash between the baseUrl and the url\n                baseUrl = ToneAudioBuffer.baseUrl === \"\" || ToneAudioBuffer.baseUrl.endsWith(\"/\") ? ToneAudioBuffer.baseUrl : ToneAudioBuffer.baseUrl + \"/\";\n                _context3.next = 26;\n                return fetch(baseUrl + url);\n\n              case 26:\n                response = _context3.sent;\n\n                if (response.ok) {\n                  _context3.next = 29;\n                  break;\n                }\n\n                throw new Error(\"could not load url: \".concat(url));\n\n              case 29:\n                _context3.next = 31;\n                return response.arrayBuffer();\n\n              case 31:\n                arrayBuffer = _context3.sent;\n                _context3.next = 34;\n                return getContext().decodeAudioData(arrayBuffer);\n\n              case 34:\n                audioBuffer = _context3.sent;\n                return _context3.abrupt(\"return\", audioBuffer);\n\n              case 36:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, null, [[5, 16, 19, 22]]);\n      }));\n    }\n    /**\n     * Checks a url's extension to see if the current browser can play that file type.\n     * @param url The url/extension to test\n     * @return If the file extension can be played\n     * @static\n     * @example\n     * Tone.ToneAudioBuffer.supportsType(\"wav\"); // returns true\n     * Tone.ToneAudioBuffer.supportsType(\"path/to/file.wav\"); // returns true\n     */\n\n  }, {\n    key: \"supportsType\",\n    value: function supportsType(url) {\n      var extensions = url.split(\".\");\n      var extension = extensions[extensions.length - 1];\n      var response = document.createElement(\"audio\").canPlayType(\"audio/\" + extension);\n      return response !== \"\";\n    }\n    /**\n     * Returns a Promise which resolves when all of the buffers have loaded\n     */\n\n  }, {\n    key: \"loaded\",\n    value: function loaded() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return Promise.resolve();\n\n              case 2:\n                if (!ToneAudioBuffer.downloads.length) {\n                  _context4.next = 7;\n                  break;\n                }\n\n                _context4.next = 5;\n                return ToneAudioBuffer.downloads[0];\n\n              case 5:\n                _context4.next = 2;\n                break;\n\n              case 7:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n    }\n  }]);\n\n  return ToneAudioBuffer;\n}(Tone); //-------------------------------------\n// STATIC METHODS\n//-------------------------------------\n\n/**\n * A path which is prefixed before every url.\n */\n\nToneAudioBuffer.baseUrl = \"\";\n/**\n * All of the downloads\n */\n\nToneAudioBuffer.downloads = [];","map":{"version":3,"sources":["../../../../Tone/core/context/ToneAudioBuffer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __awaiter } from \"tslib\";\nimport { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { isAudioBuffer } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { noOp } from \"../util/Interface\";\nimport { isArray, isNumber, isString } from \"../util/TypeCheck\";\nimport { assert } from \"../util/Debug\";\n/**\n * AudioBuffer loading and storage. ToneAudioBuffer is used internally by all\n * classes that make requests for audio files such as Tone.Player,\n * Tone.Sampler and Tone.Convolver.\n * Aside from load callbacks from individual buffers, ToneAudioBuffer\n * provides events which keep track of the loading progress\n * of _all_ of the buffers. These are ToneAudioBuffer.on(\"load\" / \"progress\" / \"error\")\n * @example\n * const buffer = new Tone.ToneAudioBuffer(\"https://tonejs.github.io/audio/casio/A1.mp3\", () => {\n * \tconsole.log(\"loaded\");\n * });\n * @category Core\n */\nexport class ToneAudioBuffer extends Tone {\n    constructor() {\n        super();\n        this.name = \"ToneAudioBuffer\";\n        /**\n         * Callback when the buffer is loaded.\n         */\n        this.onload = noOp;\n        const options = optionsFromArguments(ToneAudioBuffer.getDefaults(), arguments, [\"url\", \"onload\", \"onerror\"]);\n        this.reverse = options.reverse;\n        this.onload = options.onload;\n        if (options.url && isAudioBuffer(options.url) || options.url instanceof ToneAudioBuffer) {\n            this.set(options.url);\n        }\n        else if (isString(options.url)) {\n            // initiate the download\n            this.load(options.url).catch(options.onerror);\n        }\n    }\n    static getDefaults() {\n        return {\n            onerror: noOp,\n            onload: noOp,\n            reverse: false,\n        };\n    }\n    /**\n     * The sample rate of the AudioBuffer\n     */\n    get sampleRate() {\n        if (this._buffer) {\n            return this._buffer.sampleRate;\n        }\n        else {\n            return getContext().sampleRate;\n        }\n    }\n    /**\n     * Pass in an AudioBuffer or ToneAudioBuffer to set the value of this buffer.\n     */\n    set(buffer) {\n        if (buffer instanceof ToneAudioBuffer) {\n            // if it's loaded, set it\n            if (buffer.loaded) {\n                this._buffer = buffer.get();\n            }\n            else {\n                // otherwise when it's loaded, invoke it's callback\n                buffer.onload = () => {\n                    this.set(buffer);\n                    this.onload(this);\n                };\n            }\n        }\n        else {\n            this._buffer = buffer;\n        }\n        // reverse it initially\n        if (this._reversed) {\n            this._reverse();\n        }\n        return this;\n    }\n    /**\n     * The audio buffer stored in the object.\n     */\n    get() {\n        return this._buffer;\n    }\n    /**\n     * Makes an fetch request for the selected url then decodes the file as an audio buffer.\n     * Invokes the callback once the audio buffer loads.\n     * @param url The url of the buffer to load. filetype support depends on the browser.\n     * @returns A Promise which resolves with this ToneAudioBuffer\n     */\n    load(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const doneLoading = ToneAudioBuffer.load(url).then(audioBuffer => {\n                this.set(audioBuffer);\n                // invoke the onload method\n                this.onload(this);\n            });\n            ToneAudioBuffer.downloads.push(doneLoading);\n            try {\n                yield doneLoading;\n            }\n            finally {\n                // remove the downloaded file\n                const index = ToneAudioBuffer.downloads.indexOf(doneLoading);\n                ToneAudioBuffer.downloads.splice(index, 1);\n            }\n            return this;\n        });\n    }\n    /**\n     * clean up\n     */\n    dispose() {\n        super.dispose();\n        this._buffer = undefined;\n        return this;\n    }\n    /**\n     * Set the audio buffer from the array.\n     * To create a multichannel AudioBuffer, pass in a multidimensional array.\n     * @param array The array to fill the audio buffer\n     */\n    fromArray(array) {\n        const isMultidimensional = isArray(array) && array[0].length > 0;\n        const channels = isMultidimensional ? array.length : 1;\n        const len = isMultidimensional ? array[0].length : array.length;\n        const context = getContext();\n        const buffer = context.createBuffer(channels, len, context.sampleRate);\n        const multiChannelArray = !isMultidimensional && channels === 1 ?\n            [array] : array;\n        for (let c = 0; c < channels; c++) {\n            buffer.copyToChannel(multiChannelArray[c], c);\n        }\n        this._buffer = buffer;\n        return this;\n    }\n    /**\n     * Sums multiple channels into 1 channel\n     * @param chanNum Optionally only copy a single channel from the array.\n     */\n    toMono(chanNum) {\n        if (isNumber(chanNum)) {\n            this.fromArray(this.toArray(chanNum));\n        }\n        else {\n            let outputArray = new Float32Array(this.length);\n            const numChannels = this.numberOfChannels;\n            for (let channel = 0; channel < numChannels; channel++) {\n                const channelArray = this.toArray(channel);\n                for (let i = 0; i < channelArray.length; i++) {\n                    outputArray[i] += channelArray[i];\n                }\n            }\n            // divide by the number of channels\n            outputArray = outputArray.map(sample => sample / numChannels);\n            this.fromArray(outputArray);\n        }\n        return this;\n    }\n    /**\n     * Get the buffer as an array. Single channel buffers will return a 1-dimensional\n     * Float32Array, and multichannel buffers will return multidimensional arrays.\n     * @param channel Optionally only copy a single channel from the array.\n     */\n    toArray(channel) {\n        if (isNumber(channel)) {\n            return this.getChannelData(channel);\n        }\n        else if (this.numberOfChannels === 1) {\n            return this.toArray(0);\n        }\n        else {\n            const ret = [];\n            for (let c = 0; c < this.numberOfChannels; c++) {\n                ret[c] = this.getChannelData(c);\n            }\n            return ret;\n        }\n    }\n    /**\n     * Returns the Float32Array representing the PCM audio data for the specific channel.\n     * @param  channel  The channel number to return\n     * @return The audio as a TypedArray\n     */\n    getChannelData(channel) {\n        if (this._buffer) {\n            return this._buffer.getChannelData(channel);\n        }\n        else {\n            return new Float32Array(0);\n        }\n    }\n    /**\n     * Cut a subsection of the array and return a buffer of the\n     * subsection. Does not modify the original buffer\n     * @param start The time to start the slice\n     * @param end The end time to slice. If none is given will default to the end of the buffer\n     */\n    slice(start, end = this.duration) {\n        const startSamples = Math.floor(start * this.sampleRate);\n        const endSamples = Math.floor(end * this.sampleRate);\n        assert(startSamples < endSamples, \"The start time must be less than the end time\");\n        const length = endSamples - startSamples;\n        const retBuffer = getContext().createBuffer(this.numberOfChannels, length, this.sampleRate);\n        for (let channel = 0; channel < this.numberOfChannels; channel++) {\n            retBuffer.copyToChannel(this.getChannelData(channel).subarray(startSamples, endSamples), channel);\n        }\n        return new ToneAudioBuffer(retBuffer);\n    }\n    /**\n     * Reverse the buffer.\n     */\n    _reverse() {\n        if (this.loaded) {\n            for (let i = 0; i < this.numberOfChannels; i++) {\n                this.getChannelData(i).reverse();\n            }\n        }\n        return this;\n    }\n    /**\n     * If the buffer is loaded or not\n     */\n    get loaded() {\n        return this.length > 0;\n    }\n    /**\n     * The duration of the buffer in seconds.\n     */\n    get duration() {\n        if (this._buffer) {\n            return this._buffer.duration;\n        }\n        else {\n            return 0;\n        }\n    }\n    /**\n     * The length of the buffer in samples\n     */\n    get length() {\n        if (this._buffer) {\n            return this._buffer.length;\n        }\n        else {\n            return 0;\n        }\n    }\n    /**\n     * The number of discrete audio channels. Returns 0 if no buffer is loaded.\n     */\n    get numberOfChannels() {\n        if (this._buffer) {\n            return this._buffer.numberOfChannels;\n        }\n        else {\n            return 0;\n        }\n    }\n    /**\n     * Reverse the buffer.\n     */\n    get reverse() {\n        return this._reversed;\n    }\n    set reverse(rev) {\n        if (this._reversed !== rev) {\n            this._reversed = rev;\n            this._reverse();\n        }\n    }\n    /**\n     * Create a ToneAudioBuffer from the array. To create a multichannel AudioBuffer,\n     * pass in a multidimensional array.\n     * @param array The array to fill the audio buffer\n     * @return A ToneAudioBuffer created from the array\n     */\n    static fromArray(array) {\n        return (new ToneAudioBuffer()).fromArray(array);\n    }\n    /**\n     * Creates a ToneAudioBuffer from a URL, returns a promise which resolves to a ToneAudioBuffer\n     * @param  url The url to load.\n     * @return A promise which resolves to a ToneAudioBuffer\n     */\n    static fromUrl(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const buffer = new ToneAudioBuffer();\n            return yield buffer.load(url);\n        });\n    }\n    /**\n     * Loads a url using fetch and returns the AudioBuffer.\n     */\n    static load(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // test if the url contains multiple extensions\n            const matches = url.match(/\\[(.+\\|?)+\\]$/);\n            if (matches) {\n                const extensions = matches[1].split(\"|\");\n                let extension = extensions[0];\n                for (const ext of extensions) {\n                    if (ToneAudioBuffer.supportsType(ext)) {\n                        extension = ext;\n                        break;\n                    }\n                }\n                url = url.replace(matches[0], extension);\n            }\n            // make sure there is a slash between the baseUrl and the url\n            const baseUrl = ToneAudioBuffer.baseUrl === \"\" || ToneAudioBuffer.baseUrl.endsWith(\"/\") ? ToneAudioBuffer.baseUrl : ToneAudioBuffer.baseUrl + \"/\";\n            const response = yield fetch(baseUrl + url);\n            if (!response.ok) {\n                throw new Error(`could not load url: ${url}`);\n            }\n            const arrayBuffer = yield response.arrayBuffer();\n            const audioBuffer = yield getContext().decodeAudioData(arrayBuffer);\n            return audioBuffer;\n        });\n    }\n    /**\n     * Checks a url's extension to see if the current browser can play that file type.\n     * @param url The url/extension to test\n     * @return If the file extension can be played\n     * @static\n     * @example\n     * Tone.ToneAudioBuffer.supportsType(\"wav\"); // returns true\n     * Tone.ToneAudioBuffer.supportsType(\"path/to/file.wav\"); // returns true\n     */\n    static supportsType(url) {\n        const extensions = url.split(\".\");\n        const extension = extensions[extensions.length - 1];\n        const response = document.createElement(\"audio\").canPlayType(\"audio/\" + extension);\n        return response !== \"\";\n    }\n    /**\n     * Returns a Promise which resolves when all of the buffers have loaded\n     */\n    static loaded() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // this makes sure that the function is always async\n            yield Promise.resolve();\n            while (ToneAudioBuffer.downloads.length) {\n                yield ToneAudioBuffer.downloads[0];\n            }\n        });\n    }\n}\n//-------------------------------------\n// STATIC METHODS\n//-------------------------------------\n/**\n * A path which is prefixed before every url.\n */\nToneAudioBuffer.baseUrl = \"\";\n/**\n * All of the downloads\n */\nToneAudioBuffer.downloads = [];\n//# sourceMappingURL=ToneAudioBuffer.js.map"]},"metadata":{},"sourceType":"module"}