{"ast":null,"code":"import _slicedToArray from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _createForOfIteratorHelper from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _regeneratorRuntime from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _defineProperty from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _objectSpread from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _asyncToGenerator from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\n\nvar processBuffer = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(proxy, renderedBuffer, nativeOfflineAudioContext, options, processorConstructor, exposeCurrentFrameAndCurrentTime) {\n    var length, numberOfInputChannels, numberOfOutputChannels, processedBuffer, audioNodeConnections, audioWorkletProcessor, inputs, outputs, parameters, _loop, i, _ret;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            // Ceil the length to the next full render quantum.\n            // Bug #17: Safari does not yet expose the length.\n            length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;\n            numberOfInputChannels = options.channelCount * options.numberOfInputs;\n            numberOfOutputChannels = options.outputChannelCount.reduce(function (sum, value) {\n              return sum + value;\n            }, 0);\n            processedBuffer = numberOfOutputChannels === 0 ? null : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n\n            if (!(processorConstructor === undefined)) {\n              _context.next = 6;\n              break;\n            }\n\n            throw new Error('Missing the processor constructor.');\n\n          case 6:\n            audioNodeConnections = getAudioNodeConnections(proxy);\n            _context.next = 9;\n            return getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n\n          case 9:\n            audioWorkletProcessor = _context.sent;\n            inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n            outputs = createNestedArrays(options.numberOfOutputs, options.outputChannelCount);\n            parameters = Array.from(proxy.parameters.keys()).reduce(function (prmtrs, name) {\n              return _objectSpread(_objectSpread({}, prmtrs), {}, _defineProperty({}, name, new Float32Array(128)));\n            }, {});\n\n            _loop = function _loop(i) {\n              if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n                for (var j = 0; j < options.numberOfInputs; j += 1) {\n                  for (var k = 0; k < options.channelCount; k += 1) {\n                    copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n                  }\n                }\n              }\n\n              if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n                processorConstructor.parameterDescriptors.forEach(function (_ref2, index) {\n                  var name = _ref2.name;\n                  copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n                });\n              }\n\n              for (var _j = 0; _j < options.numberOfInputs; _j += 1) {\n                for (var _k = 0; _k < options.outputChannelCount[_j]; _k += 1) {\n                  // The byteLength will be 0 when the ArrayBuffer was transferred.\n                  if (outputs[_j][_k].byteLength === 0) {\n                    outputs[_j][_k] = new Float32Array(128);\n                  }\n                }\n              }\n\n              try {\n                var potentiallyEmptyInputs = inputs.map(function (input, index) {\n                  if (audioNodeConnections.activeInputs[index].size === 0) {\n                    return [];\n                  }\n\n                  return input;\n                });\n                var activeSourceFlag = exposeCurrentFrameAndCurrentTime(i / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, function () {\n                  return audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters);\n                });\n\n                if (processedBuffer !== null) {\n                  for (var _j2 = 0, outputChannelSplitterNodeOutput = 0; _j2 < options.numberOfOutputs; _j2 += 1) {\n                    for (var _k2 = 0; _k2 < options.outputChannelCount[_j2]; _k2 += 1) {\n                      copyToChannel(processedBuffer, outputs[_j2], _k2, outputChannelSplitterNodeOutput + _k2, i);\n                    }\n\n                    outputChannelSplitterNodeOutput += options.outputChannelCount[_j2];\n                  }\n                }\n\n                if (!activeSourceFlag) {\n                  return \"break\";\n                }\n              } catch (error) {\n                proxy.dispatchEvent(new ErrorEvent('processorerror', {\n                  error: error\n                }));\n                return \"break\";\n              }\n            };\n\n            i = 0;\n\n          case 15:\n            if (!(i < length)) {\n              _context.next = 22;\n              break;\n            }\n\n            _ret = _loop(i);\n\n            if (!(_ret === \"break\")) {\n              _context.next = 19;\n              break;\n            }\n\n            return _context.abrupt(\"break\", 22);\n\n          case 19:\n            i += 128;\n            _context.next = 15;\n            break;\n\n          case 22:\n            return _context.abrupt(\"return\", processedBuffer);\n\n          case 23:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function processBuffer(_x, _x2, _x3, _x4, _x5, _x6) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nexport var createAudioWorkletNodeRendererFactory = function createAudioWorkletNodeRendererFactory(connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) {\n  return function (name, options, processorConstructor) {\n    var renderedNativeAudioNodes = new WeakMap();\n    var processedBufferPromise = null;\n\n    var createAudioNode = /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(proxy, nativeOfflineAudioContext, trace) {\n        var nativeAudioWorkletNode, nativeOutputNodes, nativeAudioWorkletNodeIsOwnedByContext, numberOfOutputChannels, outputChannelSplitterNode, outputChannelMergerNodes, i, outputGainNode, _numberOfInputChannels, numberOfParameters, numberOfChannels, renderBuffer, _processedBuffer, audioBufferSourceNode, _nativeOutputNodes, _nativeOutputNodes2, _outputChannelSplitterNode, _outputChannelMergerNodes, _outputGainNode, _i3, outputChannelSplitterNodeOutput, outputChannelMergerNode, j, _iterator2, _step2, _step2$value, nm, audioParam, _iterator3, _step3, _step3$value, _nm, _audioParam;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                nativeAudioWorkletNode = getNativeAudioNode(proxy);\n                nativeOutputNodes = null;\n                nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext); // Bug #61: Only Chrome & Opera have an implementation of the AudioWorkletNode yet.\n\n                if (nativeAudioWorkletNodeConstructor === null) {\n                  numberOfOutputChannels = options.outputChannelCount.reduce(function (sum, value) {\n                    return sum + value;\n                  }, 0);\n                  outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n                    channelCount: Math.max(1, numberOfOutputChannels),\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    numberOfOutputs: Math.max(1, numberOfOutputChannels)\n                  });\n                  outputChannelMergerNodes = [];\n\n                  for (i = 0; i < proxy.numberOfOutputs; i += 1) {\n                    outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeOfflineAudioContext, {\n                      channelCount: 1,\n                      channelCountMode: 'explicit',\n                      channelInterpretation: 'speakers',\n                      numberOfInputs: options.outputChannelCount[i]\n                    }));\n                  }\n\n                  outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: options.channelCountMode,\n                    channelInterpretation: options.channelInterpretation,\n                    gain: 1\n                  });\n                  outputGainNode.connect = connectMultipleOutputs.bind(null, outputChannelMergerNodes);\n                  outputGainNode.disconnect = disconnectMultipleOutputs.bind(null, outputChannelMergerNodes);\n                  nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n                } else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                  nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n                }\n\n                renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]);\n\n                if (!(nativeOutputNodes !== null)) {\n                  _context4.next = 39;\n                  break;\n                }\n\n                if (!(processedBufferPromise === null)) {\n                  _context4.next = 30;\n                  break;\n                }\n\n                if (!(processorConstructor === undefined)) {\n                  _context4.next = 9;\n                  break;\n                }\n\n                throw new Error('Missing the processor constructor.');\n\n              case 9:\n                if (!(nativeOfflineAudioContextConstructor === null)) {\n                  _context4.next = 11;\n                  break;\n                }\n\n                throw new Error('Missing the native OfflineAudioContext constructor.');\n\n              case 11:\n                // Bug #47: The AudioDestinationNode in Edge and Safari gets not initialized correctly.\n                _numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n                numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n                numberOfChannels = _numberOfInputChannels + numberOfParameters;\n\n                renderBuffer = /*#__PURE__*/function () {\n                  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n                    var partialOfflineAudioContext, gainNodes, inputChannelSplitterNodes, _i, constantSourceNodes, inputChannelMergerNode, _i2, j, _iterator, _step, _step$value, index, constantSourceNode;\n\n                    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                      while (1) {\n                        switch (_context3.prev = _context3.next) {\n                          case 0:\n                            partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(numberOfChannels, // Ceil the length to the next full render quantum.\n                            // Bug #17: Safari does not yet expose the length.\n                            Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);\n                            gainNodes = [];\n                            inputChannelSplitterNodes = [];\n\n                            for (_i = 0; _i < options.numberOfInputs; _i += 1) {\n                              gainNodes.push(createNativeGainNode(partialOfflineAudioContext, {\n                                channelCount: options.channelCount,\n                                channelCountMode: options.channelCountMode,\n                                channelInterpretation: options.channelInterpretation,\n                                gain: 1\n                              }));\n                              inputChannelSplitterNodes.push(createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                                channelCount: options.channelCount,\n                                channelCountMode: 'explicit',\n                                channelInterpretation: 'discrete',\n                                numberOfOutputs: options.channelCount\n                              }));\n                            }\n\n                            _context3.next = 6;\n                            return Promise.all(Array.from(proxy.parameters.values()).map( /*#__PURE__*/function () {\n                              var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(audioParam) {\n                                var constantSourceNode;\n                                return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                                  while (1) {\n                                    switch (_context2.prev = _context2.next) {\n                                      case 0:\n                                        constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                          channelCount: 1,\n                                          channelCountMode: 'explicit',\n                                          channelInterpretation: 'discrete',\n                                          offset: audioParam.value\n                                        });\n                                        _context2.next = 3;\n                                        return renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset, trace);\n\n                                      case 3:\n                                        return _context2.abrupt(\"return\", constantSourceNode);\n\n                                      case 4:\n                                      case \"end\":\n                                        return _context2.stop();\n                                    }\n                                  }\n                                }, _callee2);\n                              }));\n\n                              return function (_x10) {\n                                return _ref5.apply(this, arguments);\n                              };\n                            }()));\n\n                          case 6:\n                            constantSourceNodes = _context3.sent;\n                            inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                              channelCount: 1,\n                              channelCountMode: 'explicit',\n                              channelInterpretation: 'speakers',\n                              numberOfInputs: Math.max(1, _numberOfInputChannels + numberOfParameters)\n                            });\n\n                            for (_i2 = 0; _i2 < options.numberOfInputs; _i2 += 1) {\n                              gainNodes[_i2].connect(inputChannelSplitterNodes[_i2]);\n\n                              for (j = 0; j < options.channelCount; j += 1) {\n                                inputChannelSplitterNodes[_i2].connect(inputChannelMergerNode, j, _i2 * options.channelCount + j);\n                              }\n                            }\n\n                            _iterator = _createForOfIteratorHelper(constantSourceNodes.entries());\n\n                            try {\n                              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                                _step$value = _slicedToArray(_step.value, 2), index = _step$value[0], constantSourceNode = _step$value[1];\n                                constantSourceNode.connect(inputChannelMergerNode, 0, _numberOfInputChannels + index);\n                                constantSourceNode.start(0);\n                              }\n                            } catch (err) {\n                              _iterator.e(err);\n                            } finally {\n                              _iterator.f();\n                            }\n\n                            inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n                            _context3.next = 14;\n                            return Promise.all(gainNodes.map(function (gainNode) {\n                              return renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode, trace);\n                            }));\n\n                          case 14:\n                            return _context3.abrupt(\"return\", renderNativeOfflineAudioContext(partialOfflineAudioContext));\n\n                          case 15:\n                          case \"end\":\n                            return _context3.stop();\n                        }\n                      }\n                    }, _callee3);\n                  }));\n\n                  return function renderBuffer() {\n                    return _ref4.apply(this, arguments);\n                  };\n                }();\n\n                _context4.t0 = processBuffer;\n                _context4.t1 = proxy;\n\n                if (!(numberOfChannels === 0)) {\n                  _context4.next = 21;\n                  break;\n                }\n\n                _context4.t2 = null;\n                _context4.next = 24;\n                break;\n\n              case 21:\n                _context4.next = 23;\n                return renderBuffer();\n\n              case 23:\n                _context4.t2 = _context4.sent;\n\n              case 24:\n                _context4.t3 = _context4.t2;\n                _context4.t4 = nativeOfflineAudioContext;\n                _context4.t5 = options;\n                _context4.t6 = processorConstructor;\n                _context4.t7 = exposeCurrentFrameAndCurrentTime;\n                processedBufferPromise = (0, _context4.t0)(_context4.t1, _context4.t3, _context4.t4, _context4.t5, _context4.t6, _context4.t7);\n\n              case 30:\n                _context4.next = 32;\n                return processedBufferPromise;\n\n              case 32:\n                _processedBuffer = _context4.sent;\n                audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n                  buffer: null,\n                  channelCount: 2,\n                  channelCountMode: 'max',\n                  channelInterpretation: 'speakers',\n                  loop: false,\n                  loopEnd: 0,\n                  loopStart: 0,\n                  playbackRate: 1\n                });\n                _nativeOutputNodes = nativeOutputNodes, _nativeOutputNodes2 = _slicedToArray(_nativeOutputNodes, 3), _outputChannelSplitterNode = _nativeOutputNodes2[0], _outputChannelMergerNodes = _nativeOutputNodes2[1], _outputGainNode = _nativeOutputNodes2[2];\n\n                if (_processedBuffer !== null) {\n                  audioBufferSourceNode.buffer = _processedBuffer;\n                  audioBufferSourceNode.start(0);\n                }\n\n                audioBufferSourceNode.connect(_outputChannelSplitterNode);\n\n                for (_i3 = 0, outputChannelSplitterNodeOutput = 0; _i3 < proxy.numberOfOutputs; _i3 += 1) {\n                  outputChannelMergerNode = _outputChannelMergerNodes[_i3];\n\n                  for (j = 0; j < options.outputChannelCount[_i3]; j += 1) {\n                    _outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                  }\n\n                  outputChannelSplitterNodeOutput += options.outputChannelCount[_i3];\n                }\n\n                return _context4.abrupt(\"return\", _outputGainNode);\n\n              case 39:\n                if (nativeAudioWorkletNodeIsOwnedByContext) {\n                  _context4.next = 59;\n                  break;\n                }\n\n                _iterator2 = _createForOfIteratorHelper(proxy.parameters.entries());\n                _context4.prev = 41;\n\n                _iterator2.s();\n\n              case 43:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context4.next = 49;\n                  break;\n                }\n\n                _step2$value = _slicedToArray(_step2.value, 2), nm = _step2$value[0], audioParam = _step2$value[1];\n                _context4.next = 47;\n                return renderAutomation(nativeOfflineAudioContext, audioParam, // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                nativeAudioWorkletNode.parameters.get(nm), trace);\n\n              case 47:\n                _context4.next = 43;\n                break;\n\n              case 49:\n                _context4.next = 54;\n                break;\n\n              case 51:\n                _context4.prev = 51;\n                _context4.t8 = _context4[\"catch\"](41);\n\n                _iterator2.e(_context4.t8);\n\n              case 54:\n                _context4.prev = 54;\n\n                _iterator2.f();\n\n                return _context4.finish(54);\n\n              case 57:\n                _context4.next = 76;\n                break;\n\n              case 59:\n                _iterator3 = _createForOfIteratorHelper(proxy.parameters.entries());\n                _context4.prev = 60;\n\n                _iterator3.s();\n\n              case 62:\n                if ((_step3 = _iterator3.n()).done) {\n                  _context4.next = 68;\n                  break;\n                }\n\n                _step3$value = _slicedToArray(_step3.value, 2), _nm = _step3$value[0], _audioParam = _step3$value[1];\n                _context4.next = 66;\n                return connectAudioParam(nativeOfflineAudioContext, _audioParam, // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                nativeAudioWorkletNode.parameters.get(_nm), trace);\n\n              case 66:\n                _context4.next = 62;\n                break;\n\n              case 68:\n                _context4.next = 73;\n                break;\n\n              case 70:\n                _context4.prev = 70;\n                _context4.t9 = _context4[\"catch\"](60);\n\n                _iterator3.e(_context4.t9);\n\n              case 73:\n                _context4.prev = 73;\n\n                _iterator3.f();\n\n                return _context4.finish(73);\n\n              case 76:\n                _context4.next = 78;\n                return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode, trace);\n\n              case 78:\n                return _context4.abrupt(\"return\", nativeAudioWorkletNode);\n\n              case 79:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, null, [[41, 51, 54, 57], [60, 70, 73, 76]]);\n      }));\n\n      return function createAudioNode(_x7, _x8, _x9) {\n        return _ref3.apply(this, arguments);\n      };\n    }();\n\n    return {\n      render: function render(proxy, nativeOfflineAudioContext, trace) {\n        deleteUnrenderedAudioWorkletNode(nativeOfflineAudioContext, proxy);\n        var renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n        if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n          return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n        }\n\n        return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n      }\n    };\n  };\n};","map":{"version":3,"sources":["../../../src/factories/audio-worklet-node-renderer-factory.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nconst processBuffer = async (proxy, renderedBuffer, nativeOfflineAudioContext, options, processorConstructor, exposeCurrentFrameAndCurrentTime) => {\n    // Ceil the length to the next full render quantum.\n    // Bug #17: Safari does not yet expose the length.\n    const length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;\n    const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n    const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n    const processedBuffer = numberOfOutputChannels === 0\n        ? null\n        : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n    if (processorConstructor === undefined) {\n        throw new Error('Missing the processor constructor.');\n    }\n    const audioNodeConnections = getAudioNodeConnections(proxy);\n    const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n    const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n    const outputs = createNestedArrays(options.numberOfOutputs, options.outputChannelCount);\n    const parameters = Array.from(proxy.parameters.keys()).reduce((prmtrs, name) => ({ ...prmtrs, [name]: new Float32Array(128) }), {});\n    for (let i = 0; i < length; i += 128) {\n        if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n            for (let j = 0; j < options.numberOfInputs; j += 1) {\n                for (let k = 0; k < options.channelCount; k += 1) {\n                    copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n                }\n            }\n        }\n        if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n            processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n            });\n        }\n        for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                // The byteLength will be 0 when the ArrayBuffer was transferred.\n                if (outputs[j][k].byteLength === 0) {\n                    outputs[j][k] = new Float32Array(128);\n                }\n            }\n        }\n        try {\n            const potentiallyEmptyInputs = inputs.map((input, index) => {\n                if (audioNodeConnections.activeInputs[index].size === 0) {\n                    return [];\n                }\n                return input;\n            });\n            const activeSourceFlag = exposeCurrentFrameAndCurrentTime(i / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n            if (processedBuffer !== null) {\n                for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                    for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                        copyToChannel(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                    }\n                    outputChannelSplitterNodeOutput += options.outputChannelCount[j];\n                }\n            }\n            if (!activeSourceFlag) {\n                break;\n            }\n        }\n        catch (error) {\n            proxy.dispatchEvent(new ErrorEvent('processorerror', { error }));\n            break;\n        }\n    }\n    return processedBuffer;\n};\nexport const createAudioWorkletNodeRendererFactory = (connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) => {\n    return (name, options, processorConstructor) => {\n        const renderedNativeAudioNodes = new WeakMap();\n        let processedBufferPromise = null;\n        const createAudioNode = async (proxy, nativeOfflineAudioContext, trace) => {\n            let nativeAudioWorkletNode = getNativeAudioNode(proxy);\n            let nativeOutputNodes = null;\n            const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);\n            // Bug #61: Only Chrome & Opera have an implementation of the AudioWorkletNode yet.\n            if (nativeAudioWorkletNodeConstructor === null) {\n                const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n                const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n                    channelCount: Math.max(1, numberOfOutputChannels),\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    numberOfOutputs: Math.max(1, numberOfOutputChannels)\n                });\n                const outputChannelMergerNodes = [];\n                for (let i = 0; i < proxy.numberOfOutputs; i += 1) {\n                    outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeOfflineAudioContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'speakers',\n                        numberOfInputs: options.outputChannelCount[i]\n                    }));\n                }\n                const outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: options.channelCountMode,\n                    channelInterpretation: options.channelInterpretation,\n                    gain: 1\n                });\n                outputGainNode.connect = connectMultipleOutputs.bind(null, outputChannelMergerNodes);\n                outputGainNode.disconnect = disconnectMultipleOutputs.bind(null, outputChannelMergerNodes);\n                nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n            }\n            else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]);\n            if (nativeOutputNodes !== null) {\n                if (processedBufferPromise === null) {\n                    if (processorConstructor === undefined) {\n                        throw new Error('Missing the processor constructor.');\n                    }\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n                    // Bug #47: The AudioDestinationNode in Edge and Safari gets not initialized correctly.\n                    const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n                    const numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n                    const numberOfChannels = numberOfInputChannels + numberOfParameters;\n                    const renderBuffer = async () => {\n                        const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(numberOfChannels, \n                        // Ceil the length to the next full render quantum.\n                        // Bug #17: Safari does not yet expose the length.\n                        Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);\n                        const gainNodes = [];\n                        const inputChannelSplitterNodes = [];\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes.push(createNativeGainNode(partialOfflineAudioContext, {\n                                channelCount: options.channelCount,\n                                channelCountMode: options.channelCountMode,\n                                channelInterpretation: options.channelInterpretation,\n                                gain: 1\n                            }));\n                            inputChannelSplitterNodes.push(createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                                channelCount: options.channelCount,\n                                channelCountMode: 'explicit',\n                                channelInterpretation: 'discrete',\n                                numberOfOutputs: options.channelCount\n                            }));\n                        }\n                        const constantSourceNodes = await Promise.all(Array.from(proxy.parameters.values()).map(async (audioParam) => {\n                            const constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                channelCount: 1,\n                                channelCountMode: 'explicit',\n                                channelInterpretation: 'discrete',\n                                offset: audioParam.value\n                            });\n                            await renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset, trace);\n                            return constantSourceNode;\n                        }));\n                        const inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                            channelCount: 1,\n                            channelCountMode: 'explicit',\n                            channelInterpretation: 'speakers',\n                            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n                        });\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n                            for (let j = 0; j < options.channelCount; j += 1) {\n                                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n                            }\n                        }\n                        for (const [index, constantSourceNode] of constantSourceNodes.entries()) {\n                            constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                            constantSourceNode.start(0);\n                        }\n                        inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n                        await Promise.all(gainNodes.map((gainNode) => renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode, trace)));\n                        return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                    };\n                    processedBufferPromise = processBuffer(proxy, numberOfChannels === 0 ? null : await renderBuffer(), nativeOfflineAudioContext, options, processorConstructor, exposeCurrentFrameAndCurrentTime);\n                }\n                const processedBuffer = await processedBufferPromise;\n                const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n                    buffer: null,\n                    channelCount: 2,\n                    channelCountMode: 'max',\n                    channelInterpretation: 'speakers',\n                    loop: false,\n                    loopEnd: 0,\n                    loopStart: 0,\n                    playbackRate: 1\n                });\n                const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;\n                if (processedBuffer !== null) {\n                    audioBufferSourceNode.buffer = processedBuffer;\n                    audioBufferSourceNode.start(0);\n                }\n                audioBufferSourceNode.connect(outputChannelSplitterNode);\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n                    for (let j = 0; j < options.outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n                    outputChannelSplitterNodeOutput += options.outputChannelCount[i];\n                }\n                return outputGainNode;\n            }\n            if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await renderAutomation(nativeOfflineAudioContext, audioParam, \n                    // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                    nativeAudioWorkletNode.parameters.get(nm), trace);\n                }\n            }\n            else {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await connectAudioParam(nativeOfflineAudioContext, audioParam, \n                    // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                    nativeAudioWorkletNode.parameters.get(nm), trace);\n                }\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode, trace);\n            return nativeAudioWorkletNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext, trace) {\n                deleteUnrenderedAudioWorkletNode(nativeOfflineAudioContext, proxy);\n                const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext, trace);\n            }\n        };\n    };\n};\n//# sourceMappingURL=audio-worklet-node-renderer-factory.js.map"]},"metadata":{},"sourceType":"module"}