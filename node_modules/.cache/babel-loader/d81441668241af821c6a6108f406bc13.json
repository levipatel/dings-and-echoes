{"ast":null,"code":"import _classCallCheck from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _get from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/levipatel/Github/DingsAndEchoes/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Volume } from \"../component/channel/Volume\";\nimport \"../core/context/Destination\";\nimport \"../core/clock/Transport\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { defaultArg } from \"../core/util/Defaults\";\nimport { noOp, readOnly } from \"../core/util/Interface\";\nimport { StateTimeline } from \"../core/util/StateTimeline\";\nimport { isDefined, isUndef } from \"../core/util/TypeCheck\";\nimport { assert, assertContextRunning } from \"../core/util/Debug\";\nimport { GT } from \"../core/util/Math\";\n/**\n * Base class for sources.\n * start/stop of this.context.transport.\n *\n * ```\n * // Multiple state change events can be chained together,\n * // but must be set in the correct order and with ascending times\n * // OK\n * state.start().stop(\"+0.2\");\n * // OK\n * state.start().stop(\"+0.2\").start(\"+0.4\").stop(\"+0.7\")\n * // BAD\n * state.stop(\"+0.2\").start();\n * // BAD\n * state.start(\"+0.3\").stop(\"+0.2\");\n * ```\n */\n\nexport var Source = /*#__PURE__*/function (_ToneAudioNode) {\n  _inherits(Source, _ToneAudioNode);\n\n  var _super = _createSuper(Source);\n\n  function Source(options) {\n    var _this;\n\n    _classCallCheck(this, Source);\n\n    _this = _super.call(this, options);\n    /**\n     * Sources have no inputs\n     */\n\n    _this.input = undefined;\n    /**\n     * Keep track of the scheduled state.\n     */\n\n    _this._state = new StateTimeline(\"stopped\");\n    /**\n     * The synced `start` callback function from the transport\n     */\n\n    _this._synced = false;\n    /**\n     * Keep track of all of the scheduled event ids\n     */\n\n    _this._scheduled = [];\n    /**\n     * Placeholder functions for syncing/unsyncing to transport\n     */\n\n    _this._syncedStart = noOp;\n    _this._syncedStop = noOp;\n    _this._state.memory = 100;\n    _this._state.increasing = true;\n    _this._volume = _this.output = new Volume({\n      context: _this.context,\n      mute: options.mute,\n      volume: options.volume\n    });\n    _this.volume = _this._volume.volume;\n    readOnly(_assertThisInitialized(_this), \"volume\");\n    _this.onstop = options.onstop;\n    return _this;\n  }\n\n  _createClass(Source, [{\n    key: \"_clampToCurrentTime\",\n\n    /**\n     * Ensure that the scheduled time is not before the current time.\n     * Should only be used when scheduled unsynced.\n     */\n    value: function _clampToCurrentTime(time) {\n      if (this._synced) {\n        return time;\n      } else {\n        return Math.max(time, this.context.currentTime);\n      }\n    }\n    /**\n     * Start the source at the specified time. If no time is given,\n     * start the source now.\n     * @param  time When the source should be started.\n     * @example\n     * const source = new Tone.Oscillator().toDestination();\n     * source.start(\"+0.5\"); // starts the source 0.5 seconds from now\n     */\n\n  }, {\n    key: \"start\",\n    value: function start(time, offset, duration) {\n      var _this2 = this;\n\n      var computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n      computedTime = this._clampToCurrentTime(computedTime); // if it's started, stop it and restart it\n\n      if (!this._synced && this._state.getValueAtTime(computedTime) === \"started\") {\n        // time should be strictly greater than the previous start time\n        assert(GT(computedTime, this._state.get(computedTime).time), \"Start time must be strictly greater than previous start time\");\n\n        this._state.cancel(computedTime);\n\n        this._state.setStateAtTime(\"started\", computedTime);\n\n        this.log(\"restart\", computedTime);\n        this.restart(computedTime, offset, duration);\n      } else {\n        this.log(\"start\", computedTime);\n\n        this._state.setStateAtTime(\"started\", computedTime);\n\n        if (this._synced) {\n          // add the offset time to the event\n          var event = this._state.get(computedTime);\n\n          if (event) {\n            event.offset = this.toSeconds(defaultArg(offset, 0));\n            event.duration = duration ? this.toSeconds(duration) : undefined;\n          }\n\n          var sched = this.context.transport.schedule(function (t) {\n            _this2._start(t, offset, duration);\n          }, computedTime);\n\n          this._scheduled.push(sched); // if the transport is already started\n          // and the time is greater than where the transport is\n\n\n          if (this.context.transport.state === \"started\" && this.context.transport.getSecondsAtTime(this.immediate()) > computedTime) {\n            this._syncedStart(this.now(), this.context.transport.seconds);\n          }\n        } else {\n          assertContextRunning(this.context);\n\n          this._start(computedTime, offset, duration);\n        }\n      }\n\n      return this;\n    }\n    /**\n     * Stop the source at the specified time. If no time is given,\n     * stop the source now.\n     * @param  time When the source should be stopped.\n     * @example\n     * const source = new Tone.Oscillator().toDestination();\n     * source.start();\n     * source.stop(\"+0.5\"); // stops the source 0.5 seconds from now\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop(time) {\n      var computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n      computedTime = this._clampToCurrentTime(computedTime);\n\n      if (this._state.getValueAtTime(computedTime) === \"started\" || isDefined(this._state.getNextState(\"started\", computedTime))) {\n        this.log(\"stop\", computedTime);\n\n        if (!this._synced) {\n          this._stop(computedTime);\n        } else {\n          var sched = this.context.transport.schedule(this._stop.bind(this), computedTime);\n\n          this._scheduled.push(sched);\n        }\n\n        this._state.cancel(computedTime);\n\n        this._state.setStateAtTime(\"stopped\", computedTime);\n      }\n\n      return this;\n    }\n    /**\n     * Restart the source.\n     */\n\n  }, {\n    key: \"restart\",\n    value: function restart(time, offset, duration) {\n      time = this.toSeconds(time);\n\n      if (this._state.getValueAtTime(time) === \"started\") {\n        this._state.cancel(time);\n\n        this._restart(time, offset, duration);\n      }\n\n      return this;\n    }\n    /**\n     * Sync the source to the Transport so that all subsequent\n     * calls to `start` and `stop` are synced to the TransportTime\n     * instead of the AudioContext time.\n     *\n     * @example\n     * const osc = new Tone.Oscillator().toDestination();\n     * // sync the source so that it plays between 0 and 0.3 on the Transport's timeline\n     * osc.sync().start(0).stop(0.3);\n     * // start the transport.\n     * Tone.Transport.start();\n     * // set it to loop once a second\n     * Tone.Transport.loop = true;\n     * Tone.Transport.loopEnd = 1;\n     */\n\n  }, {\n    key: \"sync\",\n    value: function sync() {\n      var _this3 = this;\n\n      if (!this._synced) {\n        this._synced = true;\n\n        this._syncedStart = function (time, offset) {\n          if (offset > 0) {\n            // get the playback state at that time\n            var stateEvent = _this3._state.get(offset); // listen for start events which may occur in the middle of the sync'ed time\n\n\n            if (stateEvent && stateEvent.state === \"started\" && stateEvent.time !== offset) {\n              // get the offset\n              var startOffset = offset - _this3.toSeconds(stateEvent.time);\n\n              var duration;\n\n              if (stateEvent.duration) {\n                duration = _this3.toSeconds(stateEvent.duration) - startOffset;\n              }\n\n              _this3._start(time, _this3.toSeconds(stateEvent.offset) + startOffset, duration);\n            }\n          }\n        };\n\n        this._syncedStop = function (time) {\n          var seconds = _this3.context.transport.getSecondsAtTime(Math.max(time - _this3.sampleTime, 0));\n\n          if (_this3._state.getValueAtTime(seconds) === \"started\") {\n            _this3._stop(time);\n          }\n        };\n\n        this.context.transport.on(\"start\", this._syncedStart);\n        this.context.transport.on(\"loopStart\", this._syncedStart);\n        this.context.transport.on(\"stop\", this._syncedStop);\n        this.context.transport.on(\"pause\", this._syncedStop);\n        this.context.transport.on(\"loopEnd\", this._syncedStop);\n      }\n\n      return this;\n    }\n    /**\n     * Unsync the source to the Transport. See Source.sync\n     */\n\n  }, {\n    key: \"unsync\",\n    value: function unsync() {\n      var _this4 = this;\n\n      if (this._synced) {\n        this.context.transport.off(\"stop\", this._syncedStop);\n        this.context.transport.off(\"pause\", this._syncedStop);\n        this.context.transport.off(\"loopEnd\", this._syncedStop);\n        this.context.transport.off(\"start\", this._syncedStart);\n        this.context.transport.off(\"loopStart\", this._syncedStart);\n      }\n\n      this._synced = false; // clear all of the scheduled ids\n\n      this._scheduled.forEach(function (id) {\n        return _this4.context.transport.clear(id);\n      });\n\n      this._scheduled = [];\n\n      this._state.cancel(0); // stop it also\n\n\n      this._stop(0);\n\n      return this;\n    }\n    /**\n     * Clean up.\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Source.prototype), \"dispose\", this).call(this);\n\n      this.onstop = noOp;\n      this.unsync();\n\n      this._volume.dispose();\n\n      this._state.dispose();\n\n      return this;\n    }\n  }, {\n    key: \"state\",\n\n    /**\n     * Returns the playback state of the source, either \"started\" or \"stopped\".\n     * @example\n     * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/ahntone_c3.mp3\", () => {\n     * \tplayer.start();\n     * \tconsole.log(player.state);\n     * }).toDestination();\n     */\n    get: function get() {\n      if (this._synced) {\n        if (this.context.transport.state === \"started\") {\n          return this._state.getValueAtTime(this.context.transport.seconds);\n        } else {\n          return \"stopped\";\n        }\n      } else {\n        return this._state.getValueAtTime(this.now());\n      }\n    }\n    /**\n     * Mute the output.\n     * @example\n     * const osc = new Tone.Oscillator().toDestination().start();\n     * // mute the output\n     * osc.mute = true;\n     */\n\n  }, {\n    key: \"mute\",\n    get: function get() {\n      return this._volume.mute;\n    },\n    set: function set(mute) {\n      this._volume.mute = mute;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(ToneAudioNode.getDefaults(), {\n        mute: false,\n        onstop: noOp,\n        volume: 0\n      });\n    }\n  }]);\n\n  return Source;\n}(ToneAudioNode);","map":{"version":3,"sources":["../../../Tone/source/Source.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Volume } from \"../component/channel/Volume\";\nimport \"../core/context/Destination\";\nimport \"../core/clock/Transport\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { defaultArg } from \"../core/util/Defaults\";\nimport { noOp, readOnly } from \"../core/util/Interface\";\nimport { StateTimeline } from \"../core/util/StateTimeline\";\nimport { isDefined, isUndef } from \"../core/util/TypeCheck\";\nimport { assert, assertContextRunning } from \"../core/util/Debug\";\nimport { GT } from \"../core/util/Math\";\n/**\n * Base class for sources.\n * start/stop of this.context.transport.\n *\n * ```\n * // Multiple state change events can be chained together,\n * // but must be set in the correct order and with ascending times\n * // OK\n * state.start().stop(\"+0.2\");\n * // OK\n * state.start().stop(\"+0.2\").start(\"+0.4\").stop(\"+0.7\")\n * // BAD\n * state.stop(\"+0.2\").start();\n * // BAD\n * state.start(\"+0.3\").stop(\"+0.2\");\n * ```\n */\nexport class Source extends ToneAudioNode {\n    constructor(options) {\n        super(options);\n        /**\n         * Sources have no inputs\n         */\n        this.input = undefined;\n        /**\n         * Keep track of the scheduled state.\n         */\n        this._state = new StateTimeline(\"stopped\");\n        /**\n         * The synced `start` callback function from the transport\n         */\n        this._synced = false;\n        /**\n         * Keep track of all of the scheduled event ids\n         */\n        this._scheduled = [];\n        /**\n         * Placeholder functions for syncing/unsyncing to transport\n         */\n        this._syncedStart = noOp;\n        this._syncedStop = noOp;\n        this._state.memory = 100;\n        this._state.increasing = true;\n        this._volume = this.output = new Volume({\n            context: this.context,\n            mute: options.mute,\n            volume: options.volume,\n        });\n        this.volume = this._volume.volume;\n        readOnly(this, \"volume\");\n        this.onstop = options.onstop;\n    }\n    static getDefaults() {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            mute: false,\n            onstop: noOp,\n            volume: 0,\n        });\n    }\n    /**\n     * Returns the playback state of the source, either \"started\" or \"stopped\".\n     * @example\n     * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/ahntone_c3.mp3\", () => {\n     * \tplayer.start();\n     * \tconsole.log(player.state);\n     * }).toDestination();\n     */\n    get state() {\n        if (this._synced) {\n            if (this.context.transport.state === \"started\") {\n                return this._state.getValueAtTime(this.context.transport.seconds);\n            }\n            else {\n                return \"stopped\";\n            }\n        }\n        else {\n            return this._state.getValueAtTime(this.now());\n        }\n    }\n    /**\n     * Mute the output.\n     * @example\n     * const osc = new Tone.Oscillator().toDestination().start();\n     * // mute the output\n     * osc.mute = true;\n     */\n    get mute() {\n        return this._volume.mute;\n    }\n    set mute(mute) {\n        this._volume.mute = mute;\n    }\n    /**\n     * Ensure that the scheduled time is not before the current time.\n     * Should only be used when scheduled unsynced.\n     */\n    _clampToCurrentTime(time) {\n        if (this._synced) {\n            return time;\n        }\n        else {\n            return Math.max(time, this.context.currentTime);\n        }\n    }\n    /**\n     * Start the source at the specified time. If no time is given,\n     * start the source now.\n     * @param  time When the source should be started.\n     * @example\n     * const source = new Tone.Oscillator().toDestination();\n     * source.start(\"+0.5\"); // starts the source 0.5 seconds from now\n     */\n    start(time, offset, duration) {\n        let computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n        computedTime = this._clampToCurrentTime(computedTime);\n        // if it's started, stop it and restart it\n        if (!this._synced && this._state.getValueAtTime(computedTime) === \"started\") {\n            // time should be strictly greater than the previous start time\n            assert(GT(computedTime, this._state.get(computedTime).time), \"Start time must be strictly greater than previous start time\");\n            this._state.cancel(computedTime);\n            this._state.setStateAtTime(\"started\", computedTime);\n            this.log(\"restart\", computedTime);\n            this.restart(computedTime, offset, duration);\n        }\n        else {\n            this.log(\"start\", computedTime);\n            this._state.setStateAtTime(\"started\", computedTime);\n            if (this._synced) {\n                // add the offset time to the event\n                const event = this._state.get(computedTime);\n                if (event) {\n                    event.offset = this.toSeconds(defaultArg(offset, 0));\n                    event.duration = duration ? this.toSeconds(duration) : undefined;\n                }\n                const sched = this.context.transport.schedule(t => {\n                    this._start(t, offset, duration);\n                }, computedTime);\n                this._scheduled.push(sched);\n                // if the transport is already started\n                // and the time is greater than where the transport is\n                if (this.context.transport.state === \"started\" &&\n                    this.context.transport.getSecondsAtTime(this.immediate()) > computedTime) {\n                    this._syncedStart(this.now(), this.context.transport.seconds);\n                }\n            }\n            else {\n                assertContextRunning(this.context);\n                this._start(computedTime, offset, duration);\n            }\n        }\n        return this;\n    }\n    /**\n     * Stop the source at the specified time. If no time is given,\n     * stop the source now.\n     * @param  time When the source should be stopped.\n     * @example\n     * const source = new Tone.Oscillator().toDestination();\n     * source.start();\n     * source.stop(\"+0.5\"); // stops the source 0.5 seconds from now\n     */\n    stop(time) {\n        let computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n        computedTime = this._clampToCurrentTime(computedTime);\n        if (this._state.getValueAtTime(computedTime) === \"started\" || isDefined(this._state.getNextState(\"started\", computedTime))) {\n            this.log(\"stop\", computedTime);\n            if (!this._synced) {\n                this._stop(computedTime);\n            }\n            else {\n                const sched = this.context.transport.schedule(this._stop.bind(this), computedTime);\n                this._scheduled.push(sched);\n            }\n            this._state.cancel(computedTime);\n            this._state.setStateAtTime(\"stopped\", computedTime);\n        }\n        return this;\n    }\n    /**\n     * Restart the source.\n     */\n    restart(time, offset, duration) {\n        time = this.toSeconds(time);\n        if (this._state.getValueAtTime(time) === \"started\") {\n            this._state.cancel(time);\n            this._restart(time, offset, duration);\n        }\n        return this;\n    }\n    /**\n     * Sync the source to the Transport so that all subsequent\n     * calls to `start` and `stop` are synced to the TransportTime\n     * instead of the AudioContext time.\n     *\n     * @example\n     * const osc = new Tone.Oscillator().toDestination();\n     * // sync the source so that it plays between 0 and 0.3 on the Transport's timeline\n     * osc.sync().start(0).stop(0.3);\n     * // start the transport.\n     * Tone.Transport.start();\n     * // set it to loop once a second\n     * Tone.Transport.loop = true;\n     * Tone.Transport.loopEnd = 1;\n     */\n    sync() {\n        if (!this._synced) {\n            this._synced = true;\n            this._syncedStart = (time, offset) => {\n                if (offset > 0) {\n                    // get the playback state at that time\n                    const stateEvent = this._state.get(offset);\n                    // listen for start events which may occur in the middle of the sync'ed time\n                    if (stateEvent && stateEvent.state === \"started\" && stateEvent.time !== offset) {\n                        // get the offset\n                        const startOffset = offset - this.toSeconds(stateEvent.time);\n                        let duration;\n                        if (stateEvent.duration) {\n                            duration = this.toSeconds(stateEvent.duration) - startOffset;\n                        }\n                        this._start(time, this.toSeconds(stateEvent.offset) + startOffset, duration);\n                    }\n                }\n            };\n            this._syncedStop = time => {\n                const seconds = this.context.transport.getSecondsAtTime(Math.max(time - this.sampleTime, 0));\n                if (this._state.getValueAtTime(seconds) === \"started\") {\n                    this._stop(time);\n                }\n            };\n            this.context.transport.on(\"start\", this._syncedStart);\n            this.context.transport.on(\"loopStart\", this._syncedStart);\n            this.context.transport.on(\"stop\", this._syncedStop);\n            this.context.transport.on(\"pause\", this._syncedStop);\n            this.context.transport.on(\"loopEnd\", this._syncedStop);\n        }\n        return this;\n    }\n    /**\n     * Unsync the source to the Transport. See Source.sync\n     */\n    unsync() {\n        if (this._synced) {\n            this.context.transport.off(\"stop\", this._syncedStop);\n            this.context.transport.off(\"pause\", this._syncedStop);\n            this.context.transport.off(\"loopEnd\", this._syncedStop);\n            this.context.transport.off(\"start\", this._syncedStart);\n            this.context.transport.off(\"loopStart\", this._syncedStart);\n        }\n        this._synced = false;\n        // clear all of the scheduled ids\n        this._scheduled.forEach(id => this.context.transport.clear(id));\n        this._scheduled = [];\n        this._state.cancel(0);\n        // stop it also\n        this._stop(0);\n        return this;\n    }\n    /**\n     * Clean up.\n     */\n    dispose() {\n        super.dispose();\n        this.onstop = noOp;\n        this.unsync();\n        this._volume.dispose();\n        this._state.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=Source.js.map"]},"metadata":{},"sourceType":"module"}